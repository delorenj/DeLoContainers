{
  "conversation_id": "4cb2c37e-9926-4f15-bc78-200de93eddd4",
  "next_message": null,
  "history": [
    [
      {
        "additional_context": "--- CONTEXT ENTRY BEGIN ---\nThis section (like others) contains important information that I want you to use in your responses. I have gathered this context from valuable programmatic script hooks. You must follow any requests and consider all of the information in this section\n\n--- CONTEXT ENTRY END ---\n\n",
        "env_context": {
          "env_state": {
            "operating_system": "linux",
            "current_working_directory": "/home/delorenj/docker/stacks/media",
            "environment_variables": []
          }
        },
        "content": {
          "Prompt": {
            "prompt": "delorenj in 🌐 big-chungus in docker/stacks/media on  main [!?]\n❯ docker compose up -d\n[+] Running 1/1\n ✔ Network media_default  Created                                                                                  0.0s\nexternal volume \"downloads_volume\" not found\n\nWe have to create that volume. I'd like to mount my video directory from my synology nas drive called emma at 192.168.1.50."
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "03240ed0-df56-4e8e-9fab-a4dbe9061582",
          "content": "I see you're trying to set up your media stack with Docker Compose, but you're encountering an issue with the external volume \"downloads_volume\" not being found. Let's create this volume and mount your Synology NAS directory.\n\nFirst, let's check your current docker-compose.yml file to understand how the volume is defined:",
          "tool_uses": [
            {
              "id": "tooluse_AVzw5uMUSmKSYxxaqG14LQ",
              "name": "fs_read",
              "orig_name": "fs_read",
              "args": {
                "mode": "Line",
                "path": "/home/delorenj/docker/stacks/media/docker-compose.yml"
              },
              "orig_args": {
                "mode": "Line",
                "path": "/home/delorenj/docker/stacks/media/docker-compose.yml"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "linux",
            "current_working_directory": "/home/delorenj/docker/stacks/media",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_AVzw5uMUSmKSYxxaqG14LQ",
                "content": [
                  {
                    "Text": "Failed to validate tool parameters: '/home/delorenj/docker/stacks/media/docker-compose.yml' does not exist"
                  }
                ],
                "status": "Error"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "58d5c4ff-512c-40e6-9c29-44a4858e0d2e",
          "content": "I need to check if you have a docker-compose.yml file with a different name:",
          "tool_uses": [
            {
              "id": "tooluse_qEF1s6WJR_Gt8PwF5Peo1w",
              "name": "execute_bash",
              "orig_name": "execute_bash",
              "args": {
                "command": "ls -la /home/delorenj/docker/stacks/media/",
                "summary": "Listing files in the media directory to find the Docker Compose file"
              },
              "orig_args": {
                "command": "ls -la /home/delorenj/docker/stacks/media/",
                "summary": "Listing files in the media directory to find the Docker Compose file"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "linux",
            "current_working_directory": "/home/delorenj/docker/stacks/media",
            "environment_variables": []
          }
        },
        "content": {
          "CancelledToolUses": {
            "prompt": "The user interrupted the tool execution.",
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_qEF1s6WJR_Gt8PwF5Peo1w",
                "content": [
                  {
                    "Text": "Tool use was cancelled by the user"
                  }
                ],
                "status": "Error"
              }
            ]
          }
        },
        "images": null
      },
      {
        "Response": {
          "message_id": null,
          "content": "Tool uses were interrupted, waiting for the next user prompt"
        }
      }
    ],
    [
      {
        "additional_context": "--- CONTEXT ENTRY BEGIN ---\nThis section (like others) contains important information that I want you to use in your responses. I have gathered this context from valuable programmatic script hooks. You must follow any requests and consider all of the information in this section\n\n--- CONTEXT ENTRY END ---\n\n",
        "env_context": {
          "env_state": {
            "operating_system": "linux",
            "current_working_directory": "/home/delorenj/docker/stacks/media",
            "environment_variables": []
          }
        },
        "content": {
          "Prompt": {
            "prompt": "it's here ./compose.yml"
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "42c4b452-71dd-42b5-8c08-44cd8d3c7674",
          "content": "Let me check the compose.yml file to understand how the volumes are configured:",
          "tool_uses": [
            {
              "id": "tooluse_3LYW0Zo6QuKkdGf4fKr1hg",
              "name": "fs_read",
              "orig_name": "fs_read",
              "args": {
                "mode": "Line",
                "path": "/home/delorenj/docker/stacks/media/compose.yml"
              },
              "orig_args": {
                "mode": "Line",
                "path": "/home/delorenj/docker/stacks/media/compose.yml"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "linux",
            "current_working_directory": "/home/delorenj/docker/stacks/media",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_3LYW0Zo6QuKkdGf4fKr1hg",
                "content": [
                  {
                    "Text": "services:\n  gluetun:\n    image: qmcgaw/gluetun\n    container_name: gluetun\n    restart: unless-stopped\n    cap_add:\n      - NET_ADMIN\n    environment:\n      - VPN_SERVICE_PROVIDER=custom\n      - OPENVPN_USER=${VPNAC_USER}\n      - OPENVPN_PASSWORD=${VPNAC_PASSWORD}\n      - OPENVPN_CUSTOM_CONFIG=/gluetun/netherlands.ovpn\n      - FIREWALL_VPN_INPUT_PORTS=49152,49153,49154,49155,49156\n    volumes:\n      - ./gluetun:/gluetun\n    ports:\n      - 49152:49152/tcp\n      - 49152:49152/udp\n      - 49153:49153/tcp\n      - 49153:49153/udp\n      - 49154:49154/tcp\n      - 49154:49154/udp\n      - 49155:49155/tcp\n      - 49155:49155/udp\n      - 49156:49156/tcp\n      - 49156:49156/udp\n      - 8091:8091\n    networks:\n      - proxy\n\n  vpn-monitor:\n    image: alpine:latest\n    container_name: vpn-monitor\n    restart: unless-stopped\n    command: |\n      sh -c '\n      apk add --no-cache iproute2\n      while true; do\n        if ip addr show tun0 up > /dev/null 2>&1; then\n          echo \"vpn_connected 1\" > /metrics\n        else\n          echo \"vpn_connected 0\" > /metrics\n        fi\n        sleep 30\n      done'\n    volumes:\n      - /sys/class/net:/sys/class/net:ro\n\n  qbittorrent:\n    image: linuxserver/qbittorrent:latest\n    container_name: qbittorrent\n    restart: unless-stopped\n    network_mode: \"service:gluetun\"\n    environment:\n      - WEBUI_PORT=8091\n      - PUID=${PUID}\n      - PGID=${PGID}\n    volumes:\n      - ./qbittorrent:/config\n      - downloads_volume:/downloads:cached\n      - emma_media:/video:cached\n    depends_on:\n      - gluetun\n    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.http.routers.qbittorrent.entrypoints=websecure\"\n      - \"traefik.http.routers.qbittorrent.rule=Host(`get.delo.sh`)\"\n      - \"traefik.http.routers.qbittorrent.tls=true\"\n      - \"traefik.http.routers.qbittorrent.tls.certresolver=letsencrypt\"\n      - \"traefik.http.services.qbittorrent.loadbalancer.server.port=8091\"\n      - \"traefik.docker.network=proxy\"\n\n  prowlarr:\n    image: linuxserver/prowlarr:latest\n    container_name: prowlarr\n    restart: unless-stopped\n    volumes:\n      - ./prowlarr:/config\n    networks:\n      - proxy\n    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.http.routers.prowlarr.entrypoints=websecure\"\n      - \"traefik.http.routers.prowlarr.rule=Host(`prowlarr.delo.sh`)\"\n      - \"traefik.http.routers.prowlarr.tls=true\"\n      - \"traefik.http.routers.prowlarr.tls.certresolver=letsencrypt\"\n      - \"traefik.http.services.prowlarr.loadbalancer.server.port=9696\"\n\n  jellyfin:\n    image: linuxserver/jellyfin:latest\n    container_name: jellyfin\n    restart: unless-stopped\n    volumes:\n      - ./jellyfin:/config\n      - emma_media:/media\n    networks:\n      - proxy\n    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.http.routers.jellyfin.entrypoints=websecure\"\n      - \"traefik.http.routers.jellyfin.rule=Host(`movies.delo.sh`)\"\n      - \"traefik.http.routers.jellyfin.tls=true\"\n      - \"traefik.http.routers.jellyfin.tls.certresolver=letsencrypt\"\n      - \"traefik.http.services.jellyfin.loadbalancer.server.port=8096\"\n\nvolumes:\n  emma_media:\n    external: true\n  downloads_volume:\n    external: true\n\nnetworks:\n  proxy:\n    external: true"
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "c55f09b1-d1fb-44db-9463-47fafc839f5f",
          "content": "Now I understand the issue. Your compose.yml file is referencing two external volumes:\n1. `downloads_volume` - For qBittorrent downloads\n2. `emma_media` - For your Synology NAS media directory\n\nTo fix the error, you need to create these external volumes before running docker compose. Let's create them:\n\n1. First, let's create the downloads volume:",
          "tool_uses": [
            {
              "id": "tooluse_sorNi8b9QnqOj1R6NdbRTg",
              "name": "execute_bash",
              "orig_name": "execute_bash",
              "args": {
                "command": "docker volume create downloads_volume",
                "summary": "Creating the downloads_volume Docker volume"
              },
              "orig_args": {
                "command": "docker volume create downloads_volume",
                "summary": "Creating the downloads_volume Docker volume"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "linux",
            "current_working_directory": "/home/delorenj/docker/stacks/media",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_sorNi8b9QnqOj1R6NdbRTg",
                "content": [
                  {
                    "Json": {
                      "exit_status": "0",
                      "stderr": "",
                      "stdout": "downloads_volume"
                    }
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "d9ec7eee-91d0-4855-b859-b333ade939ef",
          "content": "",
          "tool_uses": [
            {
              "id": "tooluse_ovXD-9e2SqiQbTA_JR9ipA",
              "name": "execute_bash",
              "orig_name": "execute_bash",
              "args": {
                "command": "docker volume create emma_media",
                "summary": "Creating a Docker volume for the Synology NAS mount"
              },
              "orig_args": {
                "command": "docker volume create emma_media",
                "summary": "Creating a Docker volume for the Synology NAS mount"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "linux",
            "current_working_directory": "/home/delorenj/docker/stacks/media",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_ovXD-9e2SqiQbTA_JR9ipA",
                "content": [
                  {
                    "Json": {
                      "exit_status": "0",
                      "stderr": "",
                      "stdout": "emma_media"
                    }
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "d0f5097c-ead4-40ea-a715-117dc3c4e5e7",
          "content": "Now that we've created both required external volumes, we need to mount your Synology NAS to the `emma_media` volume. There are two approaches:\n\n1. **Using Docker volume directly with NFS**:",
          "tool_uses": [
            {
              "id": "tooluse_JPQpXPAwRryapDgBCjQmOg",
              "name": "fs_write",
              "orig_name": "fs_write",
              "args": {
                "command": "create",
                "file_text": "services:\n  gluetun:\n    image: qmcgaw/gluetun\n    container_name: gluetun\n    restart: unless-stopped\n    cap_add:\n      - NET_ADMIN\n    environment:\n      - VPN_SERVICE_PROVIDER=custom\n      - OPENVPN_USER=${VPNAC_USER}\n      - OPENVPN_PASSWORD=${VPNAC_PASSWORD}\n      - OPENVPN_CUSTOM_CONFIG=/gluetun/netherlands.ovpn\n      - FIREWALL_VPN_INPUT_PORTS=49152,49153,49154,49155,49156\n    volumes:\n      - ./gluetun:/gluetun\n    ports:\n      - 49152:49152/tcp\n      - 49152:49152/udp\n      - 49153:49153/tcp\n      - 49153:49153/udp\n      - 49154:49154/tcp\n      - 49154:49154/udp\n      - 49155:49155/tcp\n      - 49155:49155/udp\n      - 49156:49156/tcp\n      - 49156:49156/udp\n      - 8091:8091\n    networks:\n      - proxy\n\n  vpn-monitor:\n    image: alpine:latest\n    container_name: vpn-monitor\n    restart: unless-stopped\n    command: |\n      sh -c '\n      apk add --no-cache iproute2\n      while true; do\n        if ip addr show tun0 up > /dev/null 2>&1; then\n          echo \"vpn_connected 1\" > /metrics\n        else\n          echo \"vpn_connected 0\" > /metrics\n        fi\n        sleep 30\n      done'\n    volumes:\n      - /sys/class/net:/sys/class/net:ro\n\n  qbittorrent:\n    image: linuxserver/qbittorrent:latest\n    container_name: qbittorrent\n    restart: unless-stopped\n    network_mode: \"service:gluetun\"\n    environment:\n      - WEBUI_PORT=8091\n      - PUID=${PUID}\n      - PGID=${PGID}\n    volumes:\n      - ./qbittorrent:/config\n      - downloads_volume:/downloads:cached\n      - emma_media:/video:cached\n    depends_on:\n      - gluetun\n    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.http.routers.qbittorrent.entrypoints=websecure\"\n      - \"traefik.http.routers.qbittorrent.rule=Host(`get.delo.sh`)\"\n      - \"traefik.http.routers.qbittorrent.tls=true\"\n      - \"traefik.http.routers.qbittorrent.tls.certresolver=letsencrypt\"\n      - \"traefik.http.services.qbittorrent.loadbalancer.server.port=8091\"\n      - \"traefik.docker.network=proxy\"\n\n  prowlarr:\n    image: linuxserver/prowlarr:latest\n    container_name: prowlarr\n    restart: unless-stopped\n    volumes:\n      - ./prowlarr:/config\n    networks:\n      - proxy\n    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.http.routers.prowlarr.entrypoints=websecure\"\n      - \"traefik.http.routers.prowlarr.rule=Host(`prowlarr.delo.sh`)\"\n      - \"traefik.http.routers.prowlarr.tls=true\"\n      - \"traefik.http.routers.prowlarr.tls.certresolver=letsencrypt\"\n      - \"traefik.http.services.prowlarr.loadbalancer.server.port=9696\"\n\n  jellyfin:\n    image: linuxserver/jellyfin:latest\n    container_name: jellyfin\n    restart: unless-stopped\n    volumes:\n      - ./jellyfin:/config\n      - emma_media:/media\n    networks:\n      - proxy\n    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.http.routers.jellyfin.entrypoints=websecure\"\n      - \"traefik.http.routers.jellyfin.rule=Host(`movies.delo.sh`)\"\n      - \"traefik.http.routers.jellyfin.tls=true\"\n      - \"traefik.http.routers.jellyfin.tls.certresolver=letsencrypt\"\n      - \"traefik.http.services.jellyfin.loadbalancer.server.port=8096\"\n\nvolumes:\n  emma_media:\n    driver: local\n    driver_opts:\n      type: nfs\n      o: addr=192.168.1.50,rw,nfsvers=4\n      device: \":/volume1/video\"\n  downloads_volume:\n    external: true\n\nnetworks:\n  proxy:\n    external: true",
                "path": "/home/delorenj/docker/stacks/media/compose.yml"
              },
              "orig_args": {
                "command": "create",
                "file_text": "services:\n  gluetun:\n    image: qmcgaw/gluetun\n    container_name: gluetun\n    restart: unless-stopped\n    cap_add:\n      - NET_ADMIN\n    environment:\n      - VPN_SERVICE_PROVIDER=custom\n      - OPENVPN_USER=${VPNAC_USER}\n      - OPENVPN_PASSWORD=${VPNAC_PASSWORD}\n      - OPENVPN_CUSTOM_CONFIG=/gluetun/netherlands.ovpn\n      - FIREWALL_VPN_INPUT_PORTS=49152,49153,49154,49155,49156\n    volumes:\n      - ./gluetun:/gluetun\n    ports:\n      - 49152:49152/tcp\n      - 49152:49152/udp\n      - 49153:49153/tcp\n      - 49153:49153/udp\n      - 49154:49154/tcp\n      - 49154:49154/udp\n      - 49155:49155/tcp\n      - 49155:49155/udp\n      - 49156:49156/tcp\n      - 49156:49156/udp\n      - 8091:8091\n    networks:\n      - proxy\n\n  vpn-monitor:\n    image: alpine:latest\n    container_name: vpn-monitor\n    restart: unless-stopped\n    command: |\n      sh -c '\n      apk add --no-cache iproute2\n      while true; do\n        if ip addr show tun0 up > /dev/null 2>&1; then\n          echo \"vpn_connected 1\" > /metrics\n        else\n          echo \"vpn_connected 0\" > /metrics\n        fi\n        sleep 30\n      done'\n    volumes:\n      - /sys/class/net:/sys/class/net:ro\n\n  qbittorrent:\n    image: linuxserver/qbittorrent:latest\n    container_name: qbittorrent\n    restart: unless-stopped\n    network_mode: \"service:gluetun\"\n    environment:\n      - WEBUI_PORT=8091\n      - PUID=${PUID}\n      - PGID=${PGID}\n    volumes:\n      - ./qbittorrent:/config\n      - downloads_volume:/downloads:cached\n      - emma_media:/video:cached\n    depends_on:\n      - gluetun\n    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.http.routers.qbittorrent.entrypoints=websecure\"\n      - \"traefik.http.routers.qbittorrent.rule=Host(`get.delo.sh`)\"\n      - \"traefik.http.routers.qbittorrent.tls=true\"\n      - \"traefik.http.routers.qbittorrent.tls.certresolver=letsencrypt\"\n      - \"traefik.http.services.qbittorrent.loadbalancer.server.port=8091\"\n      - \"traefik.docker.network=proxy\"\n\n  prowlarr:\n    image: linuxserver/prowlarr:latest\n    container_name: prowlarr\n    restart: unless-stopped\n    volumes:\n      - ./prowlarr:/config\n    networks:\n      - proxy\n    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.http.routers.prowlarr.entrypoints=websecure\"\n      - \"traefik.http.routers.prowlarr.rule=Host(`prowlarr.delo.sh`)\"\n      - \"traefik.http.routers.prowlarr.tls=true\"\n      - \"traefik.http.routers.prowlarr.tls.certresolver=letsencrypt\"\n      - \"traefik.http.services.prowlarr.loadbalancer.server.port=9696\"\n\n  jellyfin:\n    image: linuxserver/jellyfin:latest\n    container_name: jellyfin\n    restart: unless-stopped\n    volumes:\n      - ./jellyfin:/config\n      - emma_media:/media\n    networks:\n      - proxy\n    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.http.routers.jellyfin.entrypoints=websecure\"\n      - \"traefik.http.routers.jellyfin.rule=Host(`movies.delo.sh`)\"\n      - \"traefik.http.routers.jellyfin.tls=true\"\n      - \"traefik.http.routers.jellyfin.tls.certresolver=letsencrypt\"\n      - \"traefik.http.services.jellyfin.loadbalancer.server.port=8096\"\n\nvolumes:\n  emma_media:\n    driver: local\n    driver_opts:\n      type: nfs\n      o: addr=192.168.1.50,rw,nfsvers=4\n      device: \":/volume1/video\"\n  downloads_volume:\n    external: true\n\nnetworks:\n  proxy:\n    external: true",
                "path": "/home/delorenj/docker/stacks/media/compose.yml"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "linux",
            "current_working_directory": "/home/delorenj/docker/stacks/media",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_JPQpXPAwRryapDgBCjQmOg",
                "content": [
                  {
                    "Text": ""
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "Response": {
          "message_id": "4dbafc27-2c5e-48c4-b15e-b64470caa96f",
          "content": "I've updated your compose.yml file to mount your Synology NAS directly using Docker's NFS volume driver. The changes include:\n\n```yaml\nvolumes:\n  emma_media:\n    driver: local\n    driver_opts:\n      type: nfs\n      o: addr=192.168.1.50,rw,nfsvers=4\n      device: \":/volume1/video\"\n  downloads_volume:\n    external: true\n```\n\nThis configuration:\n- Uses the local driver with NFS type\n- Points to your Synology NAS at 192.168.1.50\n- Mounts the `/volume1/video` share from your NAS\n- Keeps the downloads_volume as external (which we've already created)\n\nNow you can try running your docker compose again:\n\n```bash\ndocker compose up -d\n```\n\nThis should work without the \"external volume not found\" error, and your media services will have access to your Synology NAS video directory.\n\nIf you encounter any issues with the NFS mount, you might need to:\n1. Ensure NFS is enabled on your Synology NAS\n2. Verify the path to your video directory (I assumed `/volume1/video`)\n3. Check that your NAS allows NFS connections from your Docker host"
        }
      }
    ]
  ],
  "valid_history_range": [
    0,
    8
  ],
  "transcript": [
    "> delorenj in 🌐 big-chungus in docker/stacks/media on  main [!?]> \n❯ docker compose up -d> \n[+] Running 1/1> \n ✔ Network media_default  Created                                                                                  0.0s> \nexternal volume \"downloads_volume\" not found> \n> \nWe have to create that volume. I'd like to mount my video directory from my synology nas drive called emma at 192.168.1.50.",
    "I see you're trying to set up your media stack with Docker Compose, but you're encountering an issue with the external volume \"downloads_volume\" not being found. Let's create this volume and mount your Synology NAS directory.\n\nFirst, let's check your current docker-compose.yml file to understand how the volume is defined:\n[Tool uses: fs_read]",
    "I need to check if you have a docker-compose.yml file with a different name:\n[Tool uses: execute_bash]",
    "Tool uses were interrupted, waiting for the next user prompt\n[Tool uses: none]",
    "> /help",
    "> /profile set docker",
    "> it's here ./compose.yml",
    "Let me check the compose.yml file to understand how the volumes are configured:\n[Tool uses: fs_read]",
    "Now I understand the issue. Your compose.yml file is referencing two external volumes:\n1. `downloads_volume` - For qBittorrent downloads\n2. `emma_media` - For your Synology NAS media directory\n\nTo fix the error, you need to create these external volumes before running docker compose. Let's create them:\n\n1. First, let's create the downloads volume:\n[Tool uses: execute_bash]",
    "\n[Tool uses: execute_bash]",
    "Now that we've created both required external volumes, we need to mount your Synology NAS to the `emma_media` volume. There are two approaches:\n\n1. **Using Docker volume directly with NFS**:\n[Tool uses: fs_write]",
    "I've updated your compose.yml file to mount your Synology NAS directly using Docker's NFS volume driver. The changes include:\n\n```yaml\nvolumes:\n  emma_media:\n    driver: local\n    driver_opts:\n      type: nfs\n      o: addr=192.168.1.50,rw,nfsvers=4\n      device: \":/volume1/video\"\n  downloads_volume:\n    external: true\n```\n\nThis configuration:\n- Uses the local driver with NFS type\n- Points to your Synology NAS at 192.168.1.50\n- Mounts the `/volume1/video` share from your NAS\n- Keeps the downloads_volume as external (which we've already created)\n\nNow you can try running your docker compose again:\n\n```bash\ndocker compose up -d\n```\n\nThis should work without the \"external volume not found\" error, and your media services will have access to your Synology NAS video directory.\n\nIf you encounter any issues with the NFS mount, you might need to:\n1. Ensure NFS is enabled on your Synology NAS\n2. Verify the path to your video directory (I assumed `/volume1/video`)\n3. Check that your NAS allows NFS connections from your Docker host\n[Tool uses: none]",
    "> /save mem"
  ],
  "tools": {
    "taskmaster": [
      {
        "ToolSpecification": {
          "name": "taskmaster___complexity_report",
          "description": "Display the complexity analysis report in a readable format",
          "input_schema": {
            "json": {
              "properties": {
                "file": {
                  "description": "Path to the report file (default: scripts/task-complexity-report.json)",
                  "type": "string"
                },
                "projectRoot": {
                  "type": "string",
                  "description": "The directory of the project. Must be an absolute path."
                }
              },
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "projectRoot"
              ],
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___add_dependency",
          "description": "Add a dependency relationship between two tasks",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "dependsOn": {
                  "description": "ID of task that will become a dependency",
                  "type": "string"
                },
                "projectRoot": {
                  "type": "string",
                  "description": "The directory of the project. Must be an absolute path."
                },
                "file": {
                  "type": "string",
                  "description": "Absolute path to the tasks file (default: tasks/tasks.json)"
                },
                "id": {
                  "description": "ID of task that will depend on another task",
                  "type": "string"
                }
              },
              "additionalProperties": false,
              "required": [
                "id",
                "dependsOn",
                "projectRoot"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___analyze_project_complexity",
          "description": "Analyze task complexity and generate expansion recommendations.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "properties": {
                "output": {
                  "type": "string",
                  "description": "Output file path relative to project root (default: scripts/task-complexity-report.json)."
                },
                "projectRoot": {
                  "description": "The directory of the project. Must be an absolute path.",
                  "type": "string"
                },
                "file": {
                  "type": "string",
                  "description": "Path to the tasks file relative to project root (default: tasks/tasks.json)."
                },
                "research": {
                  "type": "boolean",
                  "description": "Use Perplexity AI for research-backed analysis.",
                  "default": false
                },
                "threshold": {
                  "default": 5,
                  "description": "Complexity score threshold (1-10) to recommend expansion.",
                  "type": "integer",
                  "maximum": 10,
                  "minimum": 1
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "projectRoot"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___get_task",
          "description": "Get detailed information about a specific task",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "properties": {
                "id": {
                  "type": "string",
                  "description": "Task ID to get"
                },
                "status": {
                  "type": "string",
                  "description": "Filter subtasks by status (e.g., 'pending', 'done')"
                },
                "file": {
                  "description": "Path to the tasks file relative to project root",
                  "type": "string"
                },
                "projectRoot": {
                  "type": "string",
                  "description": "Absolute path to the project root directory (Optional, usually from session)"
                }
              },
              "type": "object",
              "required": [
                "id"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___next_task",
          "description": "Find the next task to work on based on dependencies and status",
          "input_schema": {
            "json": {
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "file": {
                  "type": "string",
                  "description": "Absolute path to the tasks file"
                },
                "projectRoot": {
                  "description": "The directory of the project. Must be an absolute path.",
                  "type": "string"
                }
              },
              "additionalProperties": false,
              "required": [
                "projectRoot"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___parse_prd",
          "description": "Parse a Product Requirements Document (PRD) text file to automatically generate initial tasks. Reinitializing the project is not necessary to run this tool. It is recommended to run parse-prd after initializing the project and creating/importing a prd.txt file in the project root's scripts/ directory.",
          "input_schema": {
            "json": {
              "properties": {
                "numTasks": {
                  "description": "Approximate number of top-level tasks to generate (default: 10). As the agent, if you have enough information, ensure to enter a number of tasks that would logically scale with project complexity. Avoid entering numbers above 50 due to context window limitations.",
                  "type": "string"
                },
                "output": {
                  "description": "Output path for tasks.json file (default: tasks/tasks.json)",
                  "type": "string"
                },
                "projectRoot": {
                  "type": "string",
                  "description": "The directory of the project. Must be an absolute path."
                },
                "append": {
                  "description": "Append generated tasks to existing file.",
                  "type": "boolean",
                  "default": false
                },
                "force": {
                  "default": false,
                  "description": "Overwrite existing output file without prompting.",
                  "type": "boolean"
                },
                "input": {
                  "description": "Absolute path to the PRD document file (.txt, .md, etc.)",
                  "type": "string",
                  "default": "scripts/prd.txt"
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "type": "object",
              "required": [
                "projectRoot"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___expand_task",
          "description": "Expand a task into subtasks for detailed implementation",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "required": [
                "id",
                "projectRoot"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "properties": {
                "force": {
                  "type": "boolean",
                  "default": false,
                  "description": "Force expansion even if subtasks exist"
                },
                "id": {
                  "type": "string",
                  "description": "ID of task to expand"
                },
                "research": {
                  "default": false,
                  "description": "Use research role for generation",
                  "type": "boolean"
                },
                "prompt": {
                  "description": "Additional context for subtask generation",
                  "type": "string"
                },
                "file": {
                  "type": "string",
                  "description": "Path to the tasks file relative to project root (e.g., tasks/tasks.json)"
                },
                "projectRoot": {
                  "type": "string",
                  "description": "The directory of the project. Must be an absolute path."
                },
                "num": {
                  "description": "Number of subtasks to generate",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___remove_dependency",
          "description": "Remove a dependency from a task",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "type": "object",
              "required": [
                "id",
                "dependsOn",
                "projectRoot"
              ],
              "properties": {
                "projectRoot": {
                  "type": "string",
                  "description": "The directory of the project. Must be an absolute path."
                },
                "dependsOn": {
                  "description": "Task ID to remove as a dependency",
                  "type": "string"
                },
                "file": {
                  "type": "string",
                  "description": "Absolute path to the tasks file (default: tasks/tasks.json)"
                },
                "id": {
                  "type": "string",
                  "description": "Task ID to remove dependency from"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___expand_all",
          "description": "Expand all pending tasks into subtasks based on complexity or defaults",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "research": {
                  "type": "boolean",
                  "description": "Enable research-backed subtask generation (e.g., using Perplexity)"
                },
                "num": {
                  "type": "string",
                  "description": "Target number of subtasks per task (uses complexity/defaults otherwise)"
                },
                "prompt": {
                  "type": "string",
                  "description": "Additional context to guide subtask generation for all tasks"
                },
                "file": {
                  "description": "Absolute path to the tasks file in the /tasks folder inside the project root (default: tasks/tasks.json)",
                  "type": "string"
                },
                "projectRoot": {
                  "description": "Absolute path to the project root directory (derived from session if possible)",
                  "type": "string"
                },
                "force": {
                  "type": "boolean",
                  "description": "Force regeneration of subtasks for tasks that already have them"
                }
              },
              "additionalProperties": false,
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___update_task",
          "description": "Updates a single task by ID with new information or context provided in the prompt.",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "prompt": {
                  "description": "New information or context to incorporate into the task",
                  "type": "string"
                },
                "file": {
                  "description": "Absolute path to the tasks file",
                  "type": "string"
                },
                "projectRoot": {
                  "description": "The directory of the project. Must be an absolute path.",
                  "type": "string"
                },
                "research": {
                  "description": "Use Perplexity AI for research-backed updates",
                  "type": "boolean"
                },
                "id": {
                  "type": "string",
                  "description": "ID of the task (e.g., '15') to update. Subtasks are supported using the update-subtask tool."
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "id",
                "prompt",
                "projectRoot"
              ],
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___clear_subtasks",
          "description": "Clear subtasks from specified tasks",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "required": [
                "projectRoot"
              ],
              "additionalProperties": false,
              "properties": {
                "all": {
                  "description": "Clear subtasks from all tasks",
                  "type": "boolean"
                },
                "file": {
                  "description": "Absolute path to the tasks file (default: tasks/tasks.json)",
                  "type": "string"
                },
                "projectRoot": {
                  "type": "string",
                  "description": "The directory of the project. Must be an absolute path."
                },
                "id": {
                  "description": "Task IDs (comma-separated) to clear subtasks from",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___remove_subtask",
          "description": "Remove a subtask from its parent task",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "projectRoot": {
                  "type": "string",
                  "description": "The directory of the project. Must be an absolute path."
                },
                "file": {
                  "description": "Absolute path to the tasks file (default: tasks/tasks.json)",
                  "type": "string"
                },
                "skipGenerate": {
                  "description": "Skip regenerating task files",
                  "type": "boolean"
                },
                "convert": {
                  "type": "boolean",
                  "description": "Convert the subtask to a standalone task instead of deleting it"
                },
                "id": {
                  "type": "string",
                  "description": "Subtask ID to remove in format 'parentId.subtaskId' (required)"
                }
              },
              "type": "object",
              "additionalProperties": false,
              "required": [
                "id",
                "projectRoot"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___generate",
          "description": "Generates individual task files in tasks/ directory based on tasks.json",
          "input_schema": {
            "json": {
              "required": [
                "projectRoot"
              ],
              "properties": {
                "output": {
                  "description": "Output directory (default: same directory as tasks file)",
                  "type": "string"
                },
                "projectRoot": {
                  "description": "The directory of the project. Must be an absolute path.",
                  "type": "string"
                },
                "file": {
                  "type": "string",
                  "description": "Absolute path to the tasks file"
                }
              },
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___remove_task",
          "description": "Remove a task or subtask permanently from the tasks list",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "id",
                "projectRoot"
              ],
              "additionalProperties": false,
              "type": "object",
              "properties": {
                "confirm": {
                  "description": "Whether to skip confirmation prompt (default: false)",
                  "type": "boolean"
                },
                "file": {
                  "description": "Absolute path to the tasks file",
                  "type": "string"
                },
                "projectRoot": {
                  "type": "string",
                  "description": "The directory of the project. Must be an absolute path."
                },
                "id": {
                  "description": "ID of the task or subtask to remove (e.g., '5' or '5.2'). Can be comma-separated to update multiple tasks/subtasks at once.",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___update",
          "description": "Update multiple upcoming tasks (with ID >= 'from' ID) based on new context or changes provided in the prompt. Use 'update_task' instead for a single specific task or 'update_subtask' for subtasks.",
          "input_schema": {
            "json": {
              "required": [
                "from",
                "prompt"
              ],
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "file": {
                  "type": "string",
                  "description": "Path to the tasks file relative to project root"
                },
                "research": {
                  "description": "Use Perplexity AI for research-backed updates",
                  "type": "boolean"
                },
                "from": {
                  "description": "Task ID from which to start updating (inclusive). IMPORTANT: This tool uses 'from', not 'id'",
                  "type": "string"
                },
                "projectRoot": {
                  "description": "The directory of the project. (Optional, usually from session)",
                  "type": "string"
                },
                "prompt": {
                  "description": "Explanation of changes or new context to apply",
                  "type": "string"
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___validate_dependencies",
          "description": "Check tasks for dependency issues (like circular references or links to non-existent tasks) without making changes.",
          "input_schema": {
            "json": {
              "properties": {
                "projectRoot": {
                  "description": "The directory of the project. Must be an absolute path.",
                  "type": "string"
                },
                "file": {
                  "description": "Absolute path to the tasks file",
                  "type": "string"
                }
              },
              "type": "object",
              "required": [
                "projectRoot"
              ],
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___add_subtask",
          "description": "Add a subtask to an existing task",
          "input_schema": {
            "json": {
              "required": [
                "id",
                "projectRoot"
              ],
              "properties": {
                "file": {
                  "description": "Absolute path to the tasks file (default: tasks/tasks.json)",
                  "type": "string"
                },
                "title": {
                  "type": "string",
                  "description": "Title for the new subtask (when creating a new subtask)"
                },
                "description": {
                  "description": "Description for the new subtask",
                  "type": "string"
                },
                "id": {
                  "description": "Parent task ID (required)",
                  "type": "string"
                },
                "projectRoot": {
                  "description": "The directory of the project. Must be an absolute path.",
                  "type": "string"
                },
                "status": {
                  "description": "Status for the new subtask (default: 'pending')",
                  "type": "string"
                },
                "skipGenerate": {
                  "type": "boolean",
                  "description": "Skip regenerating task files"
                },
                "taskId": {
                  "type": "string",
                  "description": "Existing task ID to convert to subtask"
                },
                "details": {
                  "type": "string",
                  "description": "Implementation details for the new subtask"
                },
                "dependencies": {
                  "description": "Comma-separated list of dependency IDs for the new subtask",
                  "type": "string"
                }
              },
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___models",
          "description": "Get information about available AI models or set model configurations. Run without arguments to get the current model configuration and API key status for the selected model providers.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "type": "object",
              "properties": {
                "projectRoot": {
                  "description": "The directory of the project. Must be an absolute path.",
                  "type": "string"
                },
                "listAvailableModels": {
                  "description": "List all available models not currently in use. Input/output costs values are in dollars (3 is $3.00).",
                  "type": "boolean"
                },
                "setFallback": {
                  "description": "Set the model to use if the primary fails. Model provider API key is required in the MCP config ENV.",
                  "type": "string"
                },
                "setMain": {
                  "description": "Set the primary model for task generation/updates. Model provider API key is required in the MCP config ENV.",
                  "type": "string"
                },
                "openrouter": {
                  "type": "boolean",
                  "description": "Indicates the set model ID is a custom OpenRouter model."
                },
                "setResearch": {
                  "type": "string",
                  "description": "Set the model for research-backed operations. Model provider API key is required in the MCP config ENV."
                },
                "ollama": {
                  "type": "boolean",
                  "description": "Indicates the set model ID is a custom Ollama model."
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___update_subtask",
          "description": "Appends timestamped information to a specific subtask without replacing existing content",
          "input_schema": {
            "json": {
              "properties": {
                "file": {
                  "type": "string",
                  "description": "Absolute path to the tasks file"
                },
                "research": {
                  "description": "Use Perplexity AI for research-backed updates",
                  "type": "boolean"
                },
                "id": {
                  "description": "ID of the subtask to update in format \"parentId.subtaskId\" (e.g., \"5.2\"). Parent ID is the ID of the task that contains the subtask.",
                  "type": "string"
                },
                "projectRoot": {
                  "description": "The directory of the project. Must be an absolute path.",
                  "type": "string"
                },
                "prompt": {
                  "description": "Information to add to the subtask",
                  "type": "string"
                }
              },
              "additionalProperties": false,
              "required": [
                "id",
                "prompt",
                "projectRoot"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___initialize_project",
          "description": "Initializes a new Task Master project structure by calling the core initialization logic. Creates necessary folders and configuration files for Task Master in the current directory.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "properties": {
                "projectRoot": {
                  "description": "The root directory for the project. ALWAYS SET THIS TO THE PROJECT ROOT DIRECTORY. IF NOT SET, THE TOOL WILL NOT WORK.",
                  "type": "string"
                },
                "yes": {
                  "type": "boolean",
                  "default": true,
                  "description": "Skip prompts and use default values. Always set to true for MCP tools."
                },
                "addAliases": {
                  "description": "Add shell aliases (tm, taskmaster) to shell config file.",
                  "type": "boolean",
                  "default": false
                },
                "skipInstall": {
                  "description": "Skip installing dependencies automatically. Never do this unless you are sure the project is already installed.",
                  "type": "boolean",
                  "default": false
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "projectRoot"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___set_task_status",
          "description": "Set the status of one or more tasks or subtasks.",
          "input_schema": {
            "json": {
              "properties": {
                "id": {
                  "description": "Task ID or subtask ID (e.g., '15', '15.2'). Can be comma-separated to update multiple tasks/subtasks at once.",
                  "type": "string"
                },
                "projectRoot": {
                  "description": "The directory of the project. Must be an absolute path.",
                  "type": "string"
                },
                "file": {
                  "description": "Absolute path to the tasks file",
                  "type": "string"
                },
                "status": {
                  "type": "string",
                  "description": "New status to set (e.g., 'pending', 'done', 'in-progress', 'review', 'deferred', 'cancelled'."
                }
              },
              "required": [
                "id",
                "status",
                "projectRoot"
              ],
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___add_task",
          "description": "Add a new task using AI",
          "input_schema": {
            "json": {
              "required": [
                "projectRoot"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "testStrategy": {
                  "type": "string",
                  "description": "Test strategy (for manual task creation)"
                },
                "file": {
                  "type": "string",
                  "description": "Path to the tasks file (default: tasks/tasks.json)"
                },
                "title": {
                  "description": "Task title (for manual task creation)",
                  "type": "string"
                },
                "research": {
                  "description": "Whether to use research capabilities for task creation",
                  "type": "boolean"
                },
                "description": {
                  "description": "Task description (for manual task creation)",
                  "type": "string"
                },
                "dependencies": {
                  "description": "Comma-separated list of task IDs this task depends on",
                  "type": "string"
                },
                "details": {
                  "description": "Implementation details (for manual task creation)",
                  "type": "string"
                },
                "prompt": {
                  "type": "string",
                  "description": "Description of the task to add (required if not using manual fields)"
                },
                "projectRoot": {
                  "description": "The directory of the project. Must be an absolute path.",
                  "type": "string"
                },
                "priority": {
                  "type": "string",
                  "description": "Task priority (high, medium, low)"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___get_tasks",
          "description": "Get all tasks from Task Master, optionally filtering by status and including subtasks.",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "properties": {
                "projectRoot": {
                  "type": "string",
                  "description": "The directory of the project. Must be an absolute path."
                },
                "status": {
                  "type": "string",
                  "description": "Filter tasks by status (e.g., 'pending', 'done')"
                },
                "withSubtasks": {
                  "type": "boolean",
                  "description": "Include subtasks nested within their parent tasks in the response"
                },
                "file": {
                  "type": "string",
                  "description": "Path to the tasks file (relative to project root or absolute)"
                }
              },
              "additionalProperties": false,
              "required": [
                "projectRoot"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "taskmaster___fix_dependencies",
          "description": "Fix invalid dependencies in tasks automatically",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "type": "object",
              "required": [
                "projectRoot"
              ],
              "properties": {
                "file": {
                  "type": "string",
                  "description": "Absolute path to the tasks file"
                },
                "projectRoot": {
                  "description": "The directory of the project. Must be an absolute path.",
                  "type": "string"
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      }
    ],
    "circleci_mcp_server": [
      {
        "ToolSpecification": {
          "name": "circleci_mcp_server___get_latest_pipeline_status",
          "description": "\n    This tool retrieves the status of the latest pipeline for a CircleCI project. It can be used to check pipeline status, get latest build status, or view current pipeline state.\n\n    Common use cases:\n    - Check latest pipeline status\n    - Get current build status\n    - View pipeline state\n    - Check build progress\n    - Get pipeline information\n\n    Input options (EXACTLY ONE of these THREE options must be used):\n\n    Option 1 - Project Slug and branch (BOTH required):\n    - projectSlug: The project slug obtained from listFollowedProjects tool (e.g., \"gh/organization/project\")\n    - branch: The name of the branch (required when using projectSlug)\n\n    Option 2 - Direct URL (provide ONE of these):\n    - projectURL: The URL of the CircleCI project in any of these formats:\n      * Project URL: https://app.circleci.com/pipelines/gh/organization/project\n      * Pipeline URL: https://app.circleci.com/pipelines/gh/organization/project/123\n      * Workflow URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def\n      * Job URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def/jobs/xyz\n      * Legacy Job URL: https://circleci.com/gh/organization/project/123\n\n    Option 3 - Project Detection (ALL of these must be provided together):\n    - workspaceRoot: The absolute path to the workspace root\n    - gitRemoteURL: The URL of the git remote repository\n    - branch: The name of the current branch\n    \n    Recommended Workflow:\n    1. Use listFollowedProjects tool to get a list of projects\n    2. Extract the projectSlug from the chosen project (format: \"gh/organization/project\")\n    3. Use that projectSlug with a branch name for this tool\n\n    Additional Requirements:\n    - Never call this tool with incomplete parameters\n    - If using Option 1, make sure to extract the projectSlug exactly as provided by listFollowedProjects\n    - If using Option 2, the URLs MUST be provided by the user - do not attempt to construct or guess URLs\n    - If using Option 3, ALL THREE parameters (workspaceRoot, gitRemoteURL, branch) must be provided\n    - If none of the options can be fully satisfied, ask the user for the missing information before making the tool call\n  ",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "required": [
                "params"
              ],
              "properties": {
                "params": {
                  "additionalProperties": false,
                  "properties": {
                    "gitRemoteURL": {
                      "description": "The URL of the remote git repository. This should be the URL of the repository that you cloned to your local workspace. For example: \"https://github.com/user/my-project.git\"",
                      "type": "string"
                    },
                    "branch": {
                      "description": "The name of the branch currently checked out in local workspace. This should match local git branch. For example: \"feature/my-branch\", \"bugfix/123\", \"main\", \"master\" etc.",
                      "type": "string"
                    },
                    "projectSlug": {
                      "type": "string",
                      "description": "The project slug from listFollowedProjects tool (e.g., \"gh/organization/project\"). When using this option, branch must also be provided."
                    },
                    "projectURL": {
                      "description": "The URL of the CircleCI project. Can be any of these formats:\n- Project URL with branch: https://app.circleci.com/pipelines/gh/organization/project?branch=feature-branch\n- Legacy Pipeline URL: https://circleci.com/gh/organization/project/123\n- Legacy Pipeline URL with branch: https://circleci.com/gh/organization/project/123?branch=feature-branch\n- Pipeline URL: https://app.circleci.com/pipelines/gh/organization/project/123\n- Workflow URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def\n- Job URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def/jobs/xyz",
                      "type": "string"
                    },
                    "workspaceRoot": {
                      "description": "The absolute path to the root directory of your project workspace. This should be the top-level folder containing your source code, configuration files, and dependencies. For example: \"/home/user/my-project\" or \"C:\\Users\\user\\my-project\"",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "circleci_mcp_server___run_evaluation_tests",
          "description": "\n    This tool allows the users to run evaluation tests on a circleci pipeline.\n    They can be referred to as \"Prompt Tests\" or \"Evaluation Tests\".\n\n    This tool triggers a new CircleCI pipeline and returns the URL to monitor its progress.\n    The tool will generate an appropriate circleci configuration file and trigger a pipeline using this temporary configuration.\n    The tool will return the project slug.\n\n    Input options (EXACTLY ONE of these THREE options must be used):\n\n    Option 1 - Project Slug and branch (BOTH required):\n    - projectSlug: The project slug obtained from listFollowedProjects tool (e.g., \"gh/organization/project\")\n    - branch: The name of the branch (required when using projectSlug)\n\n    Option 2 - Direct URL (provide ONE of these):\n    - projectURL: The URL of the CircleCI project in any of these formats:\n      * Project URL with branch: https://app.circleci.com/pipelines/gh/organization/project?branch=feature-branch\n      * Pipeline URL: https://app.circleci.com/pipelines/gh/organization/project/123\n      * Workflow URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def\n      * Job URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def/jobs/xyz\n\n    Option 3 - Project Detection (ALL of these must be provided together):\n    - workspaceRoot: The absolute path to the workspace root\n    - gitRemoteURL: The URL of the git remote repository\n    - branch: The name of the current branch\n\n    Test Files:\n    - promptFiles: Array of prompt template file objects from the ./prompts directory, each containing:\n      * fileName: The name of the prompt template file\n      * fileContent: The contents of the prompt template file\n\n    Pipeline Selection:\n    - If the project has multiple pipeline definitions, the tool will return a list of available pipelines\n    - You must then make another call with the chosen pipeline name using the pipelineChoiceName parameter\n    - The pipelineChoiceName must exactly match one of the pipeline names returned by the tool\n    - If the project has only one pipeline definition, pipelineChoiceName is not needed\n\n    Additional Requirements:\n    - Never call this tool with incomplete parameters\n    - If using Option 1, make sure to extract the projectSlug exactly as provided by listFollowedProjects\n    - If using Option 2, the URLs MUST be provided by the user - do not attempt to construct or guess URLs\n    - If using Option 3, ALL THREE parameters (workspaceRoot, gitRemoteURL, branch) must be provided\n    - If none of the options can be fully satisfied, ask the user for the missing information before making the tool call\n\n    Returns:\n    - A URL to the newly triggered pipeline that can be used to monitor its progress\n    ",
          "input_schema": {
            "json": {
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "params"
              ],
              "properties": {
                "params": {
                  "additionalProperties": false,
                  "type": "object",
                  "required": [
                    "promptFiles"
                  ],
                  "properties": {
                    "branch": {
                      "type": "string",
                      "description": "The name of the branch currently checked out in local workspace. This should match local git branch. For example: \"feature/my-branch\", \"bugfix/123\", \"main\", \"master\" etc."
                    },
                    "pipelineChoiceName": {
                      "type": "string",
                      "description": "The name of the pipeline to run. This parameter is only needed if the project has multiple pipeline definitions. If not provided and multiple pipelines exist, the tool will return a list of available pipelines for the user to choose from. If provided, it must exactly match one of the pipeline names returned by the tool."
                    },
                    "projectSlug": {
                      "description": "The project slug from listFollowedProjects tool (e.g., \"gh/organization/project\"). When using this option, branch must also be provided.",
                      "type": "string"
                    },
                    "projectURL": {
                      "description": "The URL of the CircleCI project. Can be any of these formats:\n- Project URL with branch: https://app.circleci.com/pipelines/gh/organization/project?branch=feature-branch\n- Pipeline URL: https://app.circleci.com/pipelines/gh/organization/project/123\n- Workflow URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def\n- Job URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def/jobs/xyz",
                      "type": "string"
                    },
                    "promptFiles": {
                      "items": {
                        "properties": {
                          "fileContent": {
                            "type": "string",
                            "description": "The contents of the prompt template file"
                          },
                          "fileName": {
                            "type": "string",
                            "description": "The name of the prompt template file"
                          }
                        },
                        "required": [
                          "fileName",
                          "fileContent"
                        ],
                        "type": "object",
                        "additionalProperties": false
                      },
                      "description": "Array of prompt template files in the ./prompts directory (e.g. <relevant-name>.prompt.yml).",
                      "type": "array"
                    },
                    "workspaceRoot": {
                      "description": "The absolute path to the root directory of your project workspace. This should be the top-level folder containing your source code, configuration files, and dependencies. For example: \"/home/user/my-project\" or \"C:\\Users\\user\\my-project\"",
                      "type": "string"
                    },
                    "gitRemoteURL": {
                      "type": "string",
                      "description": "The URL of the remote git repository. This should be the URL of the repository that you cloned to your local workspace. For example: \"https://github.com/user/my-project.git\""
                    }
                  }
                }
              },
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "circleci_mcp_server___rerun_workflow",
          "description": "\n  This tool is used to rerun a workflow from start or from the failed job.\n\n  Common use cases:\n  - Rerun a workflow from a failed job\n  - Rerun a workflow from start\n\nInput options (EXACTLY ONE of these TWO options must be used):\n\nOption 1 - Workflow ID:\n- workflowId: The ID of the workflow to rerun\n- fromFailed: true to rerun from failed, false to rerun from start. If omitted, behavior is based on workflow status. (optional)\n\nOption 2 - Workflow URL:\n- workflowURL: The URL of the workflow to rerun\n  * Workflow URL: https://app.circleci.com/pipelines/:vcsType/:orgName/:projectName/:pipelineNumber/workflows/:workflowId\n  * Workflow Job URL: https://app.circleci.com/pipelines/:vcsType/:orgName/:projectName/:pipelineNumber/workflows/:workflowId/jobs/:buildNumber\n- fromFailed: true to rerun from failed, false to rerun from start. If omitted, behavior is based on workflow status. (optional)\n  ",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "params": {
                  "additionalProperties": false,
                  "properties": {
                    "workflowId": {
                      "type": "string",
                      "description": "This should be the workflowId of the workflow that need rerun. The workflowId is an UUID. An example workflowId is a12145c5-90f8-4cc9-98f2-36cb85db9e4b"
                    },
                    "workflowURL": {
                      "type": "string",
                      "description": "The URL of the CircleCI workflow or job. Can be any of these formats:\n- Workflow URL: https://app.circleci.com/pipelines/:vcsType/:orgName/:projectName/:pipelineNumber/workflows/:workflowId- Job URL: https://app.circleci.com/pipelines/:vcsType/:orgName/:projectName/:pipelineNumber/workflows/:workflowId/jobs/:buildNumber"
                    },
                    "fromFailed": {
                      "description": "If true, reruns the workflow from failed. If false, reruns the workflow from the start. If omitted, the rerun behavior is based on the workflow status.",
                      "type": "boolean"
                    }
                  },
                  "type": "object"
                }
              },
              "required": [
                "params"
              ],
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "circleci_mcp_server___get_build_failure_logs",
          "description": "\n    This tool helps debug CircleCI build failures by retrieving failure logs.\n\n    CRITICAL REQUIREMENTS:\n    1. Truncation Handling (HIGHEST PRIORITY):\n       - ALWAYS check for <MCPTruncationWarning> in the output\n       - When present, you MUST start your response with:\n         \"WARNING: The logs have been truncated. Only showing the most recent entries. Earlier build failures may not be visible.\"\n       - Only proceed with log analysis after acknowledging the truncation\n\n    Input options (EXACTLY ONE of these THREE options must be used):\n\n    Option 1 - Project Slug and branch (BOTH required):\n    - projectSlug: The project slug obtained from listFollowedProjects tool (e.g., \"gh/organization/project\")\n    - branch: The name of the branch (required when using projectSlug)\n\n    Option 2 - Direct URL (provide ONE of these):\n    - projectURL: The URL of the CircleCI project in any of these formats:\n      * Project URL: https://app.circleci.com/pipelines/gh/organization/project\n      * Pipeline URL: https://app.circleci.com/pipelines/gh/organization/project/123\n      * Legacy Job URL: https://circleci.com/pipelines/gh/organization/project/123\n      * Workflow URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def\n      * Job URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def/jobs/xyz\n\n    Option 3 - Project Detection (ALL of these must be provided together):\n    - workspaceRoot: The absolute path to the workspace root\n    - gitRemoteURL: The URL of the git remote repository\n    - branch: The name of the current branch\n    \n    Recommended Workflow:\n    1. Use listFollowedProjects tool to get a list of projects\n    2. Extract the projectSlug from the chosen project (format: \"gh/organization/project\")\n    3. Use that projectSlug with a branch name for this tool\n\n    Additional Requirements:\n    - Never call this tool with incomplete parameters\n    - If using Option 1, make sure to extract the projectSlug exactly as provided by listFollowedProjects\n    - If using Option 2, the URLs MUST be provided by the user - do not attempt to construct or guess URLs\n    - If using Option 3, ALL THREE parameters (workspaceRoot, gitRemoteURL, branch) must be provided\n    - If none of the options can be fully satisfied, ask the user for the missing information before making the tool call\n    ",
          "input_schema": {
            "json": {
              "properties": {
                "params": {
                  "properties": {
                    "projectSlug": {
                      "description": "The project slug from listFollowedProjects tool (e.g., \"gh/organization/project\"). When using this option, branch must also be provided.",
                      "type": "string"
                    },
                    "gitRemoteURL": {
                      "type": "string",
                      "description": "The URL of the remote git repository. This should be the URL of the repository that you cloned to your local workspace. For example: \"https://github.com/user/my-project.git\""
                    },
                    "branch": {
                      "description": "The name of the branch currently checked out in local workspace. This should match local git branch. For example: \"feature/my-branch\", \"bugfix/123\", \"main\", \"master\" etc.",
                      "type": "string"
                    },
                    "projectURL": {
                      "type": "string",
                      "description": "The URL of the CircleCI project. Can be any of these formats:\n- Project URL with branch: https://app.circleci.com/pipelines/gh/organization/project?branch=feature-branch\n- Pipeline URL: https://app.circleci.com/pipelines/gh/organization/project/123\n- Workflow URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def\n- Job URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def/jobs/xyz"
                    },
                    "workspaceRoot": {
                      "description": "The absolute path to the root directory of your project workspace. This should be the top-level folder containing your source code, configuration files, and dependencies. For example: \"/home/user/my-project\" or \"C:\\Users\\user\\my-project\"",
                      "type": "string"
                    }
                  },
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "required": [
                "params"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "circleci_mcp_server___create_prompt_template",
          "description": "\n  ABOUT THIS TOOL:\n  - This tool is part of a toolchain that generates and provides test cases for a prompt template.\n  - This tool helps an AI assistant to generate a prompt template based on one of the following:\n    1. feature requirements defined by a user - in which case the tool will generate a new prompt template based on the feature requirements.\n    2. a pre-existing prompt or prompt template that a user wants to test, evaluate, or modify - in which case the tool will convert it into a more structured and testable prompt template while leaving the original prompt language relatively unchanged.\n  - This tool will return a structured prompt template (e.g. `template`) along with a context schema (e.g. ``contextSchema``) that defines the expected input parameters for the prompt template.\n  - In some cases, a user will want to add test coverage for ALL of the prompts in a given application. In these cases, the AI agent should use this tool to generate a prompt template for each prompt in the application, and should check the entire application for AI prompts that are not already covered by a prompt template in the `./prompts` directory.\n\n  WHEN SHOULD THIS TOOL BE TRIGGERED?\n  - This tool should be triggered whenever the user provides requirements for a new AI-enabled application or a new AI-enabled feature of an existing  application (i.e. one that requires a prompt request to an LLM or any AI model).\n  - This tool should also be triggered if the user provides a pre-existing prompt or prompt template from their codebase that they want to test, evaluate, or modify.\n  - This tool should be triggered even if there are pre-existing files in the `./prompts` directory with the `<relevant-name>.prompt.yml` convention (e.g. `bedtime-story-generator.prompt.yml`, `plant-care-assistant.prompt.yml`, `customer-support-chatbot.prompt.yml`, etc.). Similar files should NEVER be generated directly by the AI agent. Instead, the AI agent should use this tool to first generate a new prompt template.\n\n  PARAMETERS:\n  - params: object\n    - prompt: string (the feature requirements or pre-existing prompt/prompt template that will be used to generate a prompt template. Can be a multi-line string.)\n    - promptOrigin: \"codebase\" | \"requirements\" (indicates whether the prompt comes from an existing codebase or from new requirements)\n    - model: string (the model that the prompt template will be tested against. Explicitly specify the model if it can be inferred from the codebase. Otherwise, defaults to `gpt-4o-mini`.)\n\n  EXAMPLE USAGE (from new requirements):\n  {\n    \"params\": {\n      \"prompt\": \"Create an app that takes any topic and an age (in years), then renders a 1-minute bedtime story for a person of that age.\",\n      \"promptOrigin\": \"requirements\"\n      \"model\": \"gpt-4o-mini\"\n    }\n  }\n\n  EXAMPLE USAGE (from pre-existing prompt/prompt template in codebase):\n  {\n    \"params\": {\n      \"prompt\": \"The user wants a bedtime story about {{topic}} for a person of age {{age}} years old. Please craft a captivating tale that captivates their imagination and provides a delightful bedtime experience.\",\n      \"promptOrigin\": \"codebase\"\n      \"model\": \"claude-3-5-sonnet-latest\"\n    }\n  }\n\n  TOOL OUTPUT INSTRUCTIONS:\n  - The tool will return...\n    - a `template` that reformulates the user's prompt into a more structured format.\n    - a ``contextSchema`` that defines the expected input parameters for the template.\n    - a `promptOrigin` that indicates whether the prompt comes from an existing prompt or prompt template in the user's codebase or from new requirements.\n  - The tool output -- the `template`, ``contextSchema``, and `promptOrigin` -- will also be used as input to the `recommend_prompt_template_tests` tool to generate a list of recommended tests that can be used to test the prompt template.\n  ",
          "input_schema": {
            "json": {
              "properties": {
                "params": {
                  "properties": {
                    "prompt": {
                      "type": "string",
                      "description": "The user's application, feature, or product requirements that will be used to generate a prompt template. Alternatively, a pre-existing prompt or prompt template can be provided if a user wants to test, evaluate, or modify it. (Can be a multi-line string.)"
                    },
                    "model": {
                      "description": "The model that the prompt template will be tested against. Explicitly specify the model if it can be inferred from the codebase. Otherwise, defaults to `gpt-4o-mini`.",
                      "default": "gpt-4o-mini",
                      "type": "string"
                    },
                    "promptOrigin": {
                      "type": "string",
                      "description": "The origin of the prompt - either \"codebase\" for existing prompts from the codebase, or \"requirements\" for new prompts from requirements.",
                      "enum": [
                        "codebase",
                        "requirements"
                      ]
                    }
                  },
                  "additionalProperties": false,
                  "required": [
                    "prompt",
                    "promptOrigin"
                  ],
                  "type": "object"
                }
              },
              "additionalProperties": false,
              "required": [
                "params"
              ],
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "circleci_mcp_server___get_job_test_results",
          "description": "\n    This tool retrieves test metadata for a CircleCI job.\n\n    PRIORITY USE CASE:\n    - When asked \"are tests passing in CI?\" or similar questions about test status\n    - When asked to \"fix failed tests in CI\" or help with CI test failures\n    - Use this tool to check if tests are passing in CircleCI and identify failed tests\n    \n    Common use cases:\n    - Get test metadata for a specific job\n    - Get test metadata for all jobs in a project\n    - Get test metadata for a specific branch\n    - Get test metadata for a specific pipeline\n    - Get test metadata for a specific workflow\n    - Get test metadata for a specific job\n\n    CRITICAL REQUIREMENTS:\n    1. Truncation Handling (HIGHEST PRIORITY):\n       - ALWAYS check for <MCPTruncationWarning> in the output\n       - When present, you MUST start your response with:\n         \"WARNING: The test results have been truncated. Only showing the most recent entries. Some test data may not be visible.\"\n       - Only proceed with test result analysis after acknowledging the truncation\n\n    2. Test Result Filtering:\n       - Use filterByTestsResult parameter to filter test results:\n         * filterByTestsResult: 'failure' - Show only failed tests\n         * filterByTestsResult: 'success' - Show only successful tests\n       - When looking for failed tests, ALWAYS set filterByTestsResult to 'failure'\n       - When checking if tests are passing, set filterByTestsResult to 'success'\n\n    Input options (EXACTLY ONE of these THREE options must be used):\n\n    Option 1 - Project Slug and branch (BOTH required):\n    - projectSlug: The project slug obtained from listFollowedProjects tool (e.g., \"gh/organization/project\")\n    - branch: The name of the branch (required when using projectSlug)\n\n    Option 2 - Direct URL (provide ONE of these):\n    - projectURL: The URL of the CircleCI job in any of these formats:\n      * Job URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def/jobs/789\n      * Workflow URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def\n      * Pipeline URL: https://app.circleci.com/pipelines/gh/organization/project/123\n\n    Option 3 - Project Detection (ALL of these must be provided together):\n    - workspaceRoot: The absolute path to the workspace root\n    - gitRemoteURL: The URL of the git remote repository\n    - branch: The name of the current branch\n    \n    For simple test status checks (e.g., \"are tests passing in CI?\") or fixing failed tests, prefer Option 1 with a recent pipeline URL if available.\n\n    Additional Requirements:\n    - Never call this tool with incomplete parameters\n    - If using Option 1, make sure to extract the projectSlug exactly as provided by listFollowedProjects and include the branch parameter\n    - If using Option 2, the URL MUST be provided by the user - do not attempt to construct or guess URLs\n    - If using Option 3, ALL THREE parameters (workspaceRoot, gitRemoteURL, branch) must be provided\n    - If none of the options can be fully satisfied, ask the user for the missing information before making the tool call\n    ",
          "input_schema": {
            "json": {
              "properties": {
                "params": {
                  "additionalProperties": false,
                  "type": "object",
                  "properties": {
                    "gitRemoteURL": {
                      "description": "The URL of the remote git repository. This should be the URL of the repository that you cloned to your local workspace. For example: \"https://github.com/user/my-project.git\"",
                      "type": "string"
                    },
                    "filterByTestsResult": {
                      "enum": [
                        "failure",
                        "success"
                      ],
                      "description": "Filter the tests by result.\n      If \"failure\", only failed tests will be returned.\n      If \"success\", only successful tests will be returned.\n      ",
                      "type": "string"
                    },
                    "branch": {
                      "description": "The name of the branch currently checked out in local workspace. This should match local git branch. For example: \"feature/my-branch\", \"bugfix/123\", \"main\", \"master\" etc.",
                      "type": "string"
                    },
                    "projectURL": {
                      "type": "string",
                      "description": "The URL of the CircleCI project. Can be any of these formats:\n- Project URL: https://app.circleci.com/pipelines/gh/organization/project\n- Project URL with branch: https://app.circleci.com/pipelines/gh/organization/project?branch=feature-branch\n- Pipeline URL: https://app.circleci.com/pipelines/gh/organization/project/123\n- Workflow URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def\n- Job URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def/jobs/123"
                    },
                    "workspaceRoot": {
                      "description": "The absolute path to the root directory of your project workspace. This should be the top-level folder containing your source code, configuration files, and dependencies. For example: \"/home/user/my-project\" or \"C:\\Users\\user\\my-project\"",
                      "type": "string"
                    },
                    "projectSlug": {
                      "description": "The project slug from listFollowedProjects tool (e.g., \"gh/organization/project\"). When using this option, branch must also be provided.",
                      "type": "string"
                    }
                  }
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "required": [
                "params"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "circleci_mcp_server___run_pipeline",
          "description": "\n    This tool triggers a new CircleCI pipeline and returns the URL to monitor its progress.\n\n    Input options (EXACTLY ONE of these THREE options must be used):\n\n    Option 1 - Project Slug and branch (BOTH required):\n    - projectSlug: The project slug obtained from listFollowedProjects tool (e.g., \"gh/organization/project\")\n    - branch: The name of the branch (required when using projectSlug)\n\n    Option 2 - Direct URL (provide ONE of these):\n    - projectURL: The URL of the CircleCI project in any of these formats:\n      * Project URL with branch: https://app.circleci.com/pipelines/gh/organization/project?branch=feature-branch\n      * Pipeline URL: https://app.circleci.com/pipelines/gh/organization/project/123\n      * Workflow URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def\n      * Job URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def/jobs/xyz\n\n    Option 3 - Project Detection (ALL of these must be provided together):\n    - workspaceRoot: The absolute path to the workspace root\n    - gitRemoteURL: The URL of the git remote repository\n    - branch: The name of the current branch\n\n    Configuration:\n    - an optional configContent parameter can be provided to override the default pipeline configuration\n\n    Pipeline Selection:\n    - If the project has multiple pipeline definitions, the tool will return a list of available pipelines\n    - You must then make another call with the chosen pipeline name using the pipelineChoiceName parameter\n    - The pipelineChoiceName must exactly match one of the pipeline names returned by the tool\n    - If the project has only one pipeline definition, pipelineChoiceName is not needed\n\n    Additional Requirements:\n    - Never call this tool with incomplete parameters\n    - If using Option 1, make sure to extract the projectSlug exactly as provided by listFollowedProjects\n    - If using Option 2, the URLs MUST be provided by the user - do not attempt to construct or guess URLs\n    - If using Option 3, ALL THREE parameters (workspaceRoot, gitRemoteURL, branch) must be provided\n    - If none of the options can be fully satisfied, ask the user for the missing information before making the tool call\n\n    Returns:\n    - A URL to the newly triggered pipeline that can be used to monitor its progress\n    ",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "type": "object",
              "required": [
                "params"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "params": {
                  "additionalProperties": false,
                  "type": "object",
                  "properties": {
                    "branch": {
                      "type": "string",
                      "description": "The name of the branch currently checked out in local workspace. This should match local git branch. For example: \"feature/my-branch\", \"bugfix/123\", \"main\", \"master\" etc."
                    },
                    "pipelineChoiceName": {
                      "type": "string",
                      "description": "The name of the pipeline to run. This parameter is only needed if the project has multiple pipeline definitions. If not provided and multiple pipelines exist, the tool will return a list of available pipelines for the user to choose from. If provided, it must exactly match one of the pipeline names returned by the tool."
                    },
                    "projectSlug": {
                      "description": "The project slug from listFollowedProjects tool (e.g., \"gh/organization/project\"). When using this option, branch must also be provided.",
                      "type": "string"
                    },
                    "projectURL": {
                      "type": "string",
                      "description": "The URL of the CircleCI project. Can be any of these formats:\n- Project URL with branch: https://app.circleci.com/pipelines/gh/organization/project?branch=feature-branch\n- Pipeline URL: https://app.circleci.com/pipelines/gh/organization/project/123\n- Workflow URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def\n- Job URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def/jobs/xyz"
                    },
                    "gitRemoteURL": {
                      "description": "The URL of the remote git repository. This should be the URL of the repository that you cloned to your local workspace. For example: \"https://github.com/user/my-project.git\"",
                      "type": "string"
                    },
                    "configContent": {
                      "description": "The content of the CircleCI YAML configuration file for the pipeline.",
                      "type": "string"
                    },
                    "workspaceRoot": {
                      "description": "The absolute path to the root directory of your project workspace. This should be the top-level folder containing your source code, configuration files, and dependencies. For example: \"/home/user/my-project\" or \"C:\\Users\\user\\my-project\"",
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "circleci_mcp_server___list_followed_projects",
          "description": "\n    This tool lists all projects that the user is following on CircleCI.\n    \n    Common use cases:\n    - Identify which CircleCI projects are available to the user\n    - Select a project for subsequent operations\n    - Obtain the projectSlug needed for other CircleCI tools\n    \n    Returns:\n    - A list of projects that the user is following on CircleCI\n    - Each entry includes the project name and its projectSlug\n    \n    Workflow:\n    1. Run this tool to see available projects\n    2. User selects a project from the list\n    3. The LLM should extract and use the projectSlug (not the project name) from the selected project for subsequent tool calls\n    4. The projectSlug is required for many other CircleCI tools, and will be used for those tool calls after a project is selected\n    \n    Note: If pagination limits are reached, the tool will indicate that not all projects could be displayed.\n    \n    IMPORTANT: Do not automatically run any additional tools after this tool is called. Wait for explicit user instruction before executing further tool calls. The LLM MUST NOT invoke any other CircleCI tools until receiving a clear instruction from the user about what to do next, even if the user selects a project. It is acceptable to list out tool call options for the user to choose from, but do not execute them until instructed.\n    ",
          "input_schema": {
            "json": {
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "params": {
                  "additionalProperties": false,
                  "properties": {},
                  "type": "object"
                }
              },
              "required": [
                "params"
              ],
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "circleci_mcp_server___recommend_prompt_template_tests",
          "description": "\n  About this tool:\n  - This tool is part of a toolchain that generates and provides test cases for a prompt template.\n  - This tool generates an array of recommended tests for a given prompt template.\n\n  Parameters:\n  - params: object\n    - promptTemplate: string (the prompt template to be tested)\n    - contextSchema: object (the context schema that defines the expected input parameters for the prompt template)\n    - promptOrigin: \"codebase\" | \"requirements\" (indicates whether the prompt comes from an existing codebase or from new requirements)\n    - model: string (the model that the prompt template will be tested against)\n    \n  Example usage:\n  {\n    \"params\": {\n      \"promptTemplate\": \"The user wants a bedtime story about {{topic}} for a person of age {{age}} years old. Please craft a captivating tale that captivates their imagination and provides a delightful bedtime experience.\",\n      \"contextSchema\": {\n        \"topic\": \"string\",\n        \"age\": \"number\"\n      },\n      \"promptOrigin\": \"codebase\"\n    }\n  }\n\n  The tool will return a structured array of test cases that can be used to test the prompt template.\n\n  Tool output instructions:\n    - The tool will return a `recommendedTests` array that can be used to test the prompt template.\n  ",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "params": {
                  "properties": {
                    "promptOrigin": {
                      "type": "string",
                      "description": "The origin of the prompt template, indicating where it came from (e.g. \"codebase\" or \"requirements\").",
                      "enum": [
                        "codebase",
                        "requirements"
                      ]
                    },
                    "template": {
                      "type": "string",
                      "description": "The prompt template to be tested. Use the `promptTemplate` from the latest `create_prompt_template` tool output (if available)."
                    },
                    "contextSchema": {
                      "additionalProperties": {
                        "type": "string"
                      },
                      "description": "The context schema that defines the expected input parameters for the prompt template. Use the `contextSchema` from the latest `create_prompt_template` tool output.",
                      "type": "object"
                    },
                    "model": {
                      "description": "The model to use for generating actual prompt outputs for testing. Defaults to gpt-4o-mini.",
                      "type": "string",
                      "default": "gpt-4o-mini"
                    }
                  },
                  "required": [
                    "template",
                    "contextSchema",
                    "promptOrigin"
                  ],
                  "additionalProperties": false,
                  "type": "object"
                }
              },
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "params"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "circleci_mcp_server___find_flaky_tests",
          "description": "\n    This tool retrieves information about flaky tests in a CircleCI project. \n    \n    The agent receiving this output MUST analyze the flaky test data and implement appropriate fixes based on the specific issues identified.\n\n    CRITICAL REQUIREMENTS:\n    1. Truncation Handling (HIGHEST PRIORITY):\n       - ALWAYS check for <MCPTruncationWarning> in the output\n       - When present, you MUST start your response with:\n         \"WARNING: The logs have been truncated. Only showing the most recent entries. Earlier build failures may not be visible.\"\n       - Only proceed with log analysis after acknowledging the truncation\n\n    Input options (EXACTLY ONE of these THREE options must be used):\n\n    Option 1 - Project Slug:\n    - projectSlug: The project slug obtained from listFollowedProjects tool (e.g., \"gh/organization/project\")\n\n    Option 2 - Direct URL (provide ONE of these):\n    - projectURL: The URL of the CircleCI project in any of these formats:\n      * Project URL: https://app.circleci.com/pipelines/gh/organization/project\n      * Pipeline URL: https://app.circleci.com/pipelines/gh/organization/project/123\n      * Workflow URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def\n      * Job URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def/jobs/xyz\n\n    Option 3 - Project Detection (ALL of these must be provided together):\n    - workspaceRoot: The absolute path to the workspace root\n    - gitRemoteURL: The URL of the git remote repository\n\n    Additional Requirements:\n    - Never call this tool with incomplete parameters\n    - If using Option 1, make sure to extract the projectSlug exactly as provided by listFollowedProjects\n    - If using Option 2, the URLs MUST be provided by the user - do not attempt to construct or guess URLs\n    - If using Option 3, BOTH parameters (workspaceRoot, gitRemoteURL) must be provided\n    - If none of the options can be fully satisfied, ask the user for the missing information before making the tool call\n    ",
          "input_schema": {
            "json": {
              "required": [
                "params"
              ],
              "type": "object",
              "properties": {
                "params": {
                  "properties": {
                    "gitRemoteURL": {
                      "description": "The URL of the remote git repository. This should be the URL of the repository that you cloned to your local workspace. For example: \"https://github.com/user/my-project.git\"",
                      "type": "string"
                    },
                    "projectSlug": {
                      "description": "The project slug from listFollowedProjects tool (e.g., \"gh/organization/project\").",
                      "type": "string"
                    },
                    "projectURL": {
                      "description": "The URL of the CircleCI project. Can be any of these formats:\n- Project URL: https://app.circleci.com/pipelines/gh/organization/project\n- Project URL with branch: https://app.circleci.com/pipelines/gh/organization/project?branch=feature-branch\n- Pipeline URL: https://app.circleci.com/pipelines/gh/organization/project/123\n- Workflow URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def\n- Job URL: https://app.circleci.com/pipelines/gh/organization/project/123/workflows/abc-def/jobs/xyz",
                      "type": "string"
                    },
                    "workspaceRoot": {
                      "description": "The absolute path to the root directory of your project workspace. This should be the top-level folder containing your source code, configuration files, and dependencies. For example: \"/home/user/my-project\" or \"C:\\Users\\user\\my-project\"",
                      "type": "string"
                    }
                  },
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "circleci_mcp_server___config_helper",
          "description": "\n  This tool helps analyze and validate and fix CircleCI configuration files.\n\n  Parameters:\n  - params: An object containing:\n    - configFile: string - The full contents of the CircleCI config file as a string. This should be the raw YAML content, not a file path.\n\n  Example usage:\n  {\n    \"params\": {\n      \"configFile\": \"version: 2.1\norbs:\n  node: circleci/node@7\n...\"\n    }\n  }\n\n  Note: The configFile content should be provided as a properly escaped string with newlines represented as \n.\n\n  Tool output instructions:\n    - If the config is invalid, the tool will return the errors and the original config. Use the errors to fix the config.\n    - If the config is valid, do nothing.\n  ",
          "input_schema": {
            "json": {
              "required": [
                "params"
              ],
              "type": "object",
              "properties": {
                "params": {
                  "required": [
                    "configFile"
                  ],
                  "additionalProperties": false,
                  "type": "object",
                  "properties": {
                    "configFile": {
                      "type": "string",
                      "description": "The contents of the circleci config file. This should be the contents of the circleci config file, not the path to the file. Typically located at .circleci/config.yml"
                    }
                  }
                }
              },
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      }
    ],
    "native___": [
      {
        "ToolSpecification": {
          "name": "use_aws",
          "description": "Make an AWS CLI api call with the specified service, operation, and parameters. All arguments MUST conform to the AWS CLI specification. Should the output of the invocation indicate a malformed command, invoke help to obtain the the correct command.",
          "input_schema": {
            "json": {
              "required": [
                "region",
                "service_name",
                "operation_name",
                "label"
              ],
              "type": "object",
              "properties": {
                "region": {
                  "type": "string",
                  "description": "Region name for calling the operation on AWS."
                },
                "profile_name": {
                  "type": "string",
                  "description": "Optional: AWS profile name to use from ~/.aws/credentials. Defaults to default profile if not specified."
                },
                "label": {
                  "description": "Human readable description of the api that is being called.",
                  "type": "string"
                },
                "parameters": {
                  "type": "object",
                  "description": "The parameters for the operation. The parameter keys MUST conform to the AWS CLI specification. You should prefer to use JSON Syntax over shorthand syntax wherever possible. For parameters that are booleans, prioritize using flags with no value. Denote these flags with flag names as key and an empty string as their value. You should also prefer kebab case."
                },
                "service_name": {
                  "description": "The name of the AWS service. If you want to query s3, you should use s3api if possible.",
                  "type": "string"
                },
                "operation_name": {
                  "description": "The name of the operation to perform.",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "execute_bash",
          "description": "Execute the specified bash command.",
          "input_schema": {
            "json": {
              "properties": {
                "summary": {
                  "description": "A brief explanation of what the command does",
                  "type": "string"
                },
                "command": {
                  "description": "Bash command to execute",
                  "type": "string"
                }
              },
              "required": [
                "command"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "fs_write",
          "description": "A tool for creating and editing files\n * The `create` command will override the file at `path` if it already exists as a file, and otherwise create a new file\n * The `append` command will add content to the end of an existing file, automatically adding a newline if the file doesn't end with one. The file must exist.\n Notes for using the `str_replace` command:\n * The `old_str` parameter should match EXACTLY one or more consecutive lines from the original file. Be mindful of whitespaces!\n * If the `old_str` parameter is not unique in the file, the replacement will not be performed. Make sure to include enough context in `old_str` to make it unique\n * The `new_str` parameter should contain the edited lines that should replace the `old_str`.",
          "input_schema": {
            "json": {
              "properties": {
                "old_str": {
                  "type": "string",
                  "description": "Required parameter of `str_replace` command containing the string in `path` to replace."
                },
                "file_text": {
                  "type": "string",
                  "description": "Required parameter of `create` command, with the content of the file to be created."
                },
                "path": {
                  "description": "Absolute path to file or directory, e.g. `/repo/file.py` or `/repo`.",
                  "type": "string"
                },
                "insert_line": {
                  "description": "Required parameter of `insert` command. The `new_str` will be inserted AFTER the line `insert_line` of `path`.",
                  "type": "integer"
                },
                "command": {
                  "enum": [
                    "create",
                    "str_replace",
                    "insert",
                    "append"
                  ],
                  "type": "string",
                  "description": "The commands to run. Allowed options are: `create`, `str_replace`, `insert`, `append`."
                },
                "new_str": {
                  "type": "string",
                  "description": "Required parameter of `str_replace` command containing the new string. Required parameter of `insert` command containing the string to insert. Required parameter of `append` command containing the content to append to the file."
                }
              },
              "required": [
                "command",
                "path"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "dummy",
          "description": "This is a dummy tool. If you are seeing this that means the tool associated with this tool call is not in the list of available tools. This could be because a wrong tool name was supplied or the list of tools has changed since the conversation has started. Do not show this when user asks you to list tools.",
          "input_schema": {
            "json": {
              "type": "object",
              "required": [],
              "properties": {}
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "report_issue",
          "description": "Opens the browser to a pre-filled gh (GitHub) issue template to report chat issues, bugs, or feature requests. Pre-filled information includes the conversation transcript, chat context, and chat request IDs from the service.",
          "input_schema": {
            "json": {
              "type": "object",
              "required": [
                "title"
              ],
              "properties": {
                "steps_to_reproduce": {
                  "type": "string",
                  "description": "Optional: Previous user chat requests or steps that were taken that may have resulted in the issue or error response."
                },
                "title": {
                  "description": "The title of the GitHub issue.",
                  "type": "string"
                },
                "actual_behavior": {
                  "description": "Optional: The actual chat behavior that happened and demonstrates the issue or lack of a feature.",
                  "type": "string"
                },
                "expected_behavior": {
                  "description": "Optional: The expected chat behavior or action that did not happen.",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "fs_read",
          "description": "Tool for reading files (for example, `cat -n`),  directories (for example, `ls -la`) and images. If user has supplied paths that appear to be leading to images, you should use this tool right away using Image mode. The behavior of this tool is determined by the `mode` parameter. The available modes are:\n- line: Show lines in a file, given by an optional `start_line` and optional `end_line`.\n- directory: List directory contents. Content is returned in the \"long format\" of ls (that is, `ls -la`).\n- search: Search for a pattern in a file. The pattern is a string. The matching is case insensitive.\n\nExample Usage:\n1. Read all lines from a file: command=\"line\", path=\"/path/to/file.txt\"\n2. Read the last 5 lines from a file: command=\"line\", path=\"/path/to/file.txt\", start_line=-5\n3. List the files in the home directory: command=\"line\", path=\"~\"\n4. Recursively list files in a directory to a max depth of 2: command=\"line\", path=\"/path/to/directory\", depth=2\n5. Search for all instances of \"test\" in a file: command=\"search\", path=\"/path/to/file.txt\", pattern=\"test\"\n",
          "input_schema": {
            "json": {
              "type": "object",
              "required": [
                "path",
                "mode"
              ],
              "properties": {
                "end_line": {
                  "description": "Ending line number (optional, for Line mode). A negative index represents a line number starting from the end of the file.",
                  "default": -1,
                  "type": "integer"
                },
                "start_line": {
                  "description": "Starting line number (optional, for Line mode). A negative index represents a line number starting from the end of the file.",
                  "type": "integer",
                  "default": 1
                },
                "context_lines": {
                  "type": "integer",
                  "default": 2,
                  "description": "Number of context lines around search results (optional, for Search mode)"
                },
                "depth": {
                  "default": 0,
                  "description": "Depth of a recursive directory listing (optional, for Directory mode)",
                  "type": "integer"
                },
                "image_paths": {
                  "description": "List of paths to the images. This is currently supported by the Image mode.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "pattern": {
                  "description": "Pattern to search for (required, for Search mode). Case insensitive. The pattern matching is performed per line.",
                  "type": "string"
                },
                "mode": {
                  "description": "The mode to run in: `Line`, `Directory`, `Search`. `Line` and `Search` are only for text files, and `Directory` is only for directories. `Image` is for image files, in this mode `image_paths` is required.",
                  "enum": [
                    "Line",
                    "Directory",
                    "Search",
                    "Image"
                  ],
                  "type": "string"
                },
                "path": {
                  "description": "Path to the file or directory. The path should be absolute, or otherwise start with ~ for the user's home.",
                  "type": "string"
                }
              }
            }
          }
        }
      }
    ],
    "mcp_datetime": [
      {
        "ToolSpecification": {
          "name": "mcp_datetime___get_datetime",
          "description": "Get current date and time in various formats",
          "input_schema": {
            "json": {
              "required": [
                "format"
              ],
              "properties": {
                "format": {
                  "description": "\nAvailable formats:\n- date: 2024-12-10\n- date_slash: 2024/12/10\n- date_jp: 2024年12月10日\n- datetime: 2024-12-10 00:54:01\n- datetime_jp: 2024年12月10日 00時54分01秒\n- datetime_t: 2024-12-10T00:54:01\n- compact: 20241210005401\n- compact_date: 20241210\n- compact_time: 005401\n- filename_md: 20241210005401.md\n- filename_txt: 20241210005401.txt\n- filename_log: 20241210005401.log\n- iso: 2024-12-10T00:54:01+0900\n- iso_basic: 20241210T005401+0900\n- log: 2024-12-10 00:54:01.123456\n- log_compact: 20241210_005401\n- time: 00:54:01\n- time_jp: 00時54分01秒\n",
                  "type": "string"
                }
              },
              "type": "object"
            }
          }
        }
      }
    ],
    "context_7": [
      {
        "ToolSpecification": {
          "name": "context_7___resolvelibraryid",
          "description": "Resolves a package/product name to a Context7-compatible library ID and returns a list of matching libraries.\n\nYou MUST call this function before 'get-library-docs' to obtain a valid Context7-compatible library ID UNLESS the user explicitly provides a library ID in the format '/org/project' or '/org/project/version' in their query.\n\nSelection Process:\n1. Analyze the query to understand what library/package the user is looking for\n2. Return the most relevant match based on:\n- Name similarity to the query (exact matches prioritized)\n- Description relevance to the query's intent\n- Documentation coverage (prioritize libraries with higher Code Snippet counts)\n- Trust score (consider libraries with scores of 7-10 more authoritative)\n\nResponse Format:\n- Return the selected library ID in a clearly marked section\n- Provide a brief explanation for why this library was chosen\n- If multiple good matches exist, acknowledge this but proceed with the most relevant one\n- If no good matches exist, clearly state this and suggest query refinements\n\nFor ambiguous queries, request clarification before proceeding with a best-guess match.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "properties": {
                "libraryName": {
                  "type": "string",
                  "description": "Library name to search for and retrieve a Context7-compatible library ID."
                }
              },
              "required": [
                "libraryName"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "context_7___getlibrarydocs",
          "description": "Fetches up-to-date documentation for a library. You must call 'resolve-library-id' first to obtain the exact Context7-compatible library ID required to use this tool, UNLESS the user explicitly provides a library ID in the format '/org/project' or '/org/project/version' in their query.",
          "input_schema": {
            "json": {
              "required": [
                "context7CompatibleLibraryID"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "type": "object",
              "properties": {
                "context7CompatibleLibraryID": {
                  "description": "Exact Context7-compatible library ID (e.g., '/mongodb/docs', '/vercel/next.js', '/supabase/supabase', '/vercel/next.js/v14.3.0-canary.87') retrieved from 'resolve-library-id' or directly from user query in the format '/org/project' or '/org/project/version'.",
                  "type": "string"
                },
                "topic": {
                  "description": "Topic to focus documentation on (e.g., 'hooks', 'routing').",
                  "type": "string"
                },
                "tokens": {
                  "description": "Maximum number of tokens of documentation to retrieve (default: 10000). Higher values provide more context but consume more tokens.",
                  "type": "number"
                }
              }
            }
          }
        }
      }
    ],
    "github": [
      {
        "ToolSpecification": {
          "name": "github___create_pending_pull_request_review",
          "description": "Create a pending review for a pull request. Call this first before attempting to add comments to a pending review, and ultimately submitting it. A pending pull request review means a pull request review, it is pending because you create it first and submit it later, and the PR author will not see it until it is submitted.",
          "input_schema": {
            "json": {
              "required": [
                "owner",
                "repo",
                "pullNumber"
              ],
              "type": "object",
              "properties": {
                "pullNumber": {
                  "type": "number",
                  "description": "Pull request number"
                },
                "repo": {
                  "type": "string",
                  "description": "Repository name"
                },
                "owner": {
                  "description": "Repository owner",
                  "type": "string"
                },
                "commitID": {
                  "description": "SHA of commit to review",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___list_secret_scanning_alerts",
          "description": "List secret scanning alerts in a GitHub repository.",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "owner": {
                  "description": "The owner of the repository.",
                  "type": "string"
                },
                "state": {
                  "description": "Filter by state",
                  "enum": [
                    "open",
                    "resolved"
                  ],
                  "type": "string"
                },
                "secret_type": {
                  "description": "A comma-separated list of secret types to return. All default secret patterns are returned. To return generic patterns, pass the token name(s) in the parameter.",
                  "type": "string"
                },
                "repo": {
                  "description": "The name of the repository.",
                  "type": "string"
                },
                "resolution": {
                  "description": "Filter by resolution",
                  "enum": [
                    "false_positive",
                    "wont_fix",
                    "revoked",
                    "pattern_edited",
                    "pattern_deleted",
                    "used_in_tests"
                  ],
                  "type": "string"
                }
              },
              "required": [
                "owner",
                "repo"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___get_pull_request_files",
          "description": "Get the files changed in a specific pull request.",
          "input_schema": {
            "json": {
              "required": [
                "owner",
                "repo",
                "pullNumber"
              ],
              "type": "object",
              "properties": {
                "owner": {
                  "description": "Repository owner",
                  "type": "string"
                },
                "pullNumber": {
                  "type": "number",
                  "description": "Pull request number"
                },
                "repo": {
                  "description": "Repository name",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___list_issues",
          "description": "List issues in a GitHub repository.",
          "input_schema": {
            "json": {
              "required": [
                "owner",
                "repo"
              ],
              "properties": {
                "labels": {
                  "description": "Filter by labels",
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                "owner": {
                  "type": "string",
                  "description": "Repository owner"
                },
                "page": {
                  "minimum": 1,
                  "description": "Page number for pagination (min 1)",
                  "type": "number"
                },
                "perPage": {
                  "type": "number",
                  "minimum": 1,
                  "description": "Results per page for pagination (min 1, max 100)",
                  "maximum": 100
                },
                "since": {
                  "type": "string",
                  "description": "Filter by date (ISO 8601 timestamp)"
                },
                "sort": {
                  "type": "string",
                  "description": "Sort order",
                  "enum": [
                    "created",
                    "updated",
                    "comments"
                  ]
                },
                "direction": {
                  "description": "Sort direction",
                  "enum": [
                    "asc",
                    "desc"
                  ],
                  "type": "string"
                },
                "repo": {
                  "description": "Repository name",
                  "type": "string"
                },
                "state": {
                  "description": "Filter by state",
                  "type": "string",
                  "enum": [
                    "open",
                    "closed",
                    "all"
                  ]
                }
              },
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___create_or_update_file",
          "description": "Create or update a single file in a GitHub repository. If updating, you must provide the SHA of the file you want to update.",
          "input_schema": {
            "json": {
              "required": [
                "owner",
                "repo",
                "path",
                "content",
                "message",
                "branch"
              ],
              "properties": {
                "sha": {
                  "description": "SHA of file being replaced (for updates)",
                  "type": "string"
                },
                "content": {
                  "type": "string",
                  "description": "Content of the file"
                },
                "owner": {
                  "type": "string",
                  "description": "Repository owner (username or organization)"
                },
                "path": {
                  "type": "string",
                  "description": "Path where to create/update the file"
                },
                "repo": {
                  "type": "string",
                  "description": "Repository name"
                },
                "message": {
                  "type": "string",
                  "description": "Commit message"
                },
                "branch": {
                  "type": "string",
                  "description": "Branch to create/update the file in"
                }
              },
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___manage_repository_notification_subscription",
          "description": "Manage a repository notification subscription: ignore, watch, or delete repository notifications subscription for the provided repository.",
          "input_schema": {
            "json": {
              "required": [
                "owner",
                "repo",
                "action"
              ],
              "type": "object",
              "properties": {
                "action": {
                  "description": "Action to perform: ignore, watch, or delete the repository notification subscription.",
                  "enum": [
                    "ignore",
                    "watch",
                    "delete"
                  ],
                  "type": "string"
                },
                "owner": {
                  "description": "The account owner of the repository.",
                  "type": "string"
                },
                "repo": {
                  "type": "string",
                  "description": "The name of the repository."
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___get_me",
          "description": "Get details of the authenticated GitHub user. Use this when a request includes \"me\", \"my\". The output will not change unless the user changes their profile, so only call this once.",
          "input_schema": {
            "json": {
              "properties": {
                "reason": {
                  "description": "Optional: the reason for requesting the user information",
                  "type": "string"
                }
              },
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___get_code_scanning_alert",
          "description": "Get details of a specific code scanning alert in a GitHub repository.",
          "input_schema": {
            "json": {
              "required": [
                "owner",
                "repo",
                "alertNumber"
              ],
              "properties": {
                "alertNumber": {
                  "type": "number",
                  "description": "The number of the alert."
                },
                "repo": {
                  "description": "The name of the repository.",
                  "type": "string"
                },
                "owner": {
                  "type": "string",
                  "description": "The owner of the repository."
                }
              },
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___search_repositories",
          "description": "Search for GitHub repositories",
          "input_schema": {
            "json": {
              "type": "object",
              "required": [
                "query"
              ],
              "properties": {
                "page": {
                  "description": "Page number for pagination (min 1)",
                  "minimum": 1,
                  "type": "number"
                },
                "perPage": {
                  "maximum": 100,
                  "minimum": 1,
                  "description": "Results per page for pagination (min 1, max 100)",
                  "type": "number"
                },
                "query": {
                  "description": "Search query",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___get_pull_request_comments",
          "description": "Get comments for a specific pull request.",
          "input_schema": {
            "json": {
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "Repository name"
                },
                "pullNumber": {
                  "description": "Pull request number",
                  "type": "number"
                },
                "owner": {
                  "description": "Repository owner",
                  "type": "string"
                }
              },
              "required": [
                "owner",
                "repo",
                "pullNumber"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___add_pull_request_review_comment_to_pending_review",
          "description": "Add a comment to the requester's latest pending pull request review, a pending review needs to already exist to call this (check with the user if not sure). If you are using the LINE subjectType, use the get_line_number_in_pull_request_file tool to get an exact line number before commenting.",
          "input_schema": {
            "json": {
              "type": "object",
              "required": [
                "owner",
                "repo",
                "pullNumber",
                "path",
                "body",
                "subjectType"
              ],
              "properties": {
                "startLine": {
                  "description": "For multi-line comments, the first line of the range that the comment applies to",
                  "type": "number"
                },
                "side": {
                  "enum": [
                    "LEFT",
                    "RIGHT"
                  ],
                  "description": "The side of the diff to comment on. LEFT indicates the previous state, RIGHT indicates the new state",
                  "type": "string"
                },
                "startSide": {
                  "enum": [
                    "LEFT",
                    "RIGHT"
                  ],
                  "description": "For multi-line comments, the starting side of the diff that the comment applies to. LEFT indicates the previous state, RIGHT indicates the new state",
                  "type": "string"
                },
                "path": {
                  "description": "The relative path to the file that necessitates a comment",
                  "type": "string"
                },
                "subjectType": {
                  "description": "The level at which the comment is targeted",
                  "type": "string",
                  "enum": [
                    "FILE",
                    "LINE"
                  ]
                },
                "body": {
                  "type": "string",
                  "description": "The text of the review comment"
                },
                "line": {
                  "type": "number",
                  "description": "The line of the blob in the pull request diff that the comment applies to. For multi-line comments, the last line of the range"
                },
                "repo": {
                  "description": "Repository name",
                  "type": "string"
                },
                "pullNumber": {
                  "type": "number",
                  "description": "Pull request number"
                },
                "owner": {
                  "type": "string",
                  "description": "Repository owner"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___manage_notification_subscription",
          "description": "Manage a notification subscription: ignore, watch, or delete a notification thread subscription.",
          "input_schema": {
            "json": {
              "required": [
                "notificationID",
                "action"
              ],
              "properties": {
                "notificationID": {
                  "type": "string",
                  "description": "The ID of the notification thread."
                },
                "action": {
                  "description": "Action to perform: ignore, watch, or delete the notification subscription.",
                  "enum": [
                    "ignore",
                    "watch",
                    "delete"
                  ],
                  "type": "string"
                }
              },
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___search_code",
          "description": "Search for code across GitHub repositories",
          "input_schema": {
            "json": {
              "required": [
                "q"
              ],
              "properties": {
                "page": {
                  "minimum": 1,
                  "description": "Page number for pagination (min 1)",
                  "type": "number"
                },
                "q": {
                  "description": "Search query using GitHub code search syntax",
                  "type": "string"
                },
                "order": {
                  "enum": [
                    "asc",
                    "desc"
                  ],
                  "type": "string",
                  "description": "Sort order"
                },
                "perPage": {
                  "description": "Results per page for pagination (min 1, max 100)",
                  "maximum": 100,
                  "type": "number",
                  "minimum": 1
                },
                "sort": {
                  "description": "Sort field ('indexed' only)",
                  "type": "string"
                }
              },
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___update_pull_request_branch",
          "description": "Update the branch of a pull request with the latest changes from the base branch.",
          "input_schema": {
            "json": {
              "properties": {
                "owner": {
                  "type": "string",
                  "description": "Repository owner"
                },
                "pullNumber": {
                  "description": "Pull request number",
                  "type": "number"
                },
                "repo": {
                  "type": "string",
                  "description": "Repository name"
                },
                "expectedHeadSha": {
                  "type": "string",
                  "description": "The expected SHA of the pull request's HEAD ref"
                }
              },
              "type": "object",
              "required": [
                "owner",
                "repo",
                "pullNumber"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___submit_pending_pull_request_review",
          "description": "Submit the requester's latest pending pull request review, normally this is a final step after creating a pending review, adding comments first, unless you know that the user already did the first two steps, you should check before calling this.",
          "input_schema": {
            "json": {
              "required": [
                "owner",
                "repo",
                "pullNumber",
                "event"
              ],
              "properties": {
                "pullNumber": {
                  "description": "Pull request number",
                  "type": "number"
                },
                "repo": {
                  "description": "Repository name",
                  "type": "string"
                },
                "body": {
                  "description": "The text of the review comment",
                  "type": "string"
                },
                "event": {
                  "enum": [
                    "APPROVE",
                    "REQUEST_CHANGES",
                    "COMMENT"
                  ],
                  "type": "string",
                  "description": "The event to perform"
                },
                "owner": {
                  "description": "Repository owner",
                  "type": "string"
                }
              },
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___get_file_contents",
          "description": "Get the contents of a file or directory from a GitHub repository",
          "input_schema": {
            "json": {
              "properties": {
                "branch": {
                  "description": "Branch to get contents from",
                  "type": "string"
                },
                "owner": {
                  "description": "Repository owner (username or organization)",
                  "type": "string"
                },
                "path": {
                  "type": "string",
                  "description": "Path to file/directory"
                },
                "repo": {
                  "type": "string",
                  "description": "Repository name"
                }
              },
              "required": [
                "owner",
                "repo",
                "path"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___get_issue",
          "description": "Get details of a specific issue in a GitHub repository.",
          "input_schema": {
            "json": {
              "required": [
                "owner",
                "repo",
                "issue_number"
              ],
              "type": "object",
              "properties": {
                "owner": {
                  "description": "The owner of the repository",
                  "type": "string"
                },
                "repo": {
                  "type": "string",
                  "description": "The name of the repository"
                },
                "issue_number": {
                  "description": "The number of the issue",
                  "type": "number"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___dismiss_notification",
          "description": "Dismiss a notification by marking it as read or done",
          "input_schema": {
            "json": {
              "required": [
                "threadID"
              ],
              "type": "object",
              "properties": {
                "threadID": {
                  "description": "The ID of the notification thread",
                  "type": "string"
                },
                "state": {
                  "description": "The new state of the notification (read/done)",
                  "type": "string",
                  "enum": [
                    "read",
                    "done"
                  ]
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___get_pull_request_status",
          "description": "Get the status of a specific pull request.",
          "input_schema": {
            "json": {
              "properties": {
                "pullNumber": {
                  "description": "Pull request number",
                  "type": "number"
                },
                "owner": {
                  "type": "string",
                  "description": "Repository owner"
                },
                "repo": {
                  "type": "string",
                  "description": "Repository name"
                }
              },
              "required": [
                "owner",
                "repo",
                "pullNumber"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___create_branch",
          "description": "Create a new branch in a GitHub repository",
          "input_schema": {
            "json": {
              "properties": {
                "branch": {
                  "description": "Name for new branch",
                  "type": "string"
                },
                "repo": {
                  "type": "string",
                  "description": "Repository name"
                },
                "from_branch": {
                  "description": "Source branch (defaults to repo default)",
                  "type": "string"
                },
                "owner": {
                  "type": "string",
                  "description": "Repository owner"
                }
              },
              "required": [
                "owner",
                "repo",
                "branch"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___list_commits",
          "description": "Get list of commits of a branch in a GitHub repository",
          "input_schema": {
            "json": {
              "properties": {
                "owner": {
                  "description": "Repository owner",
                  "type": "string"
                },
                "perPage": {
                  "type": "number",
                  "description": "Results per page for pagination (min 1, max 100)",
                  "maximum": 100,
                  "minimum": 1
                },
                "repo": {
                  "description": "Repository name",
                  "type": "string"
                },
                "page": {
                  "minimum": 1,
                  "type": "number",
                  "description": "Page number for pagination (min 1)"
                },
                "sha": {
                  "type": "string",
                  "description": "SHA or Branch name"
                }
              },
              "required": [
                "owner",
                "repo"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___update_pull_request",
          "description": "Update an existing pull request in a GitHub repository.",
          "input_schema": {
            "json": {
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "Repository name"
                },
                "title": {
                  "type": "string",
                  "description": "New title"
                },
                "maintainer_can_modify": {
                  "type": "boolean",
                  "description": "Allow maintainer edits"
                },
                "owner": {
                  "description": "Repository owner",
                  "type": "string"
                },
                "pullNumber": {
                  "description": "Pull request number to update",
                  "type": "number"
                },
                "state": {
                  "enum": [
                    "open",
                    "closed"
                  ],
                  "type": "string",
                  "description": "New state"
                },
                "base": {
                  "type": "string",
                  "description": "New base branch name"
                },
                "body": {
                  "type": "string",
                  "description": "New description"
                }
              },
              "required": [
                "owner",
                "repo",
                "pullNumber"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___get_pull_request_diff",
          "description": "Get the diff of a pull request.",
          "input_schema": {
            "json": {
              "properties": {
                "owner": {
                  "type": "string",
                  "description": "Repository owner"
                },
                "repo": {
                  "description": "Repository name",
                  "type": "string"
                },
                "pullNumber": {
                  "type": "number",
                  "description": "Pull request number"
                }
              },
              "required": [
                "owner",
                "repo",
                "pullNumber"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___list_branches",
          "description": "List branches in a GitHub repository",
          "input_schema": {
            "json": {
              "properties": {
                "owner": {
                  "type": "string",
                  "description": "Repository owner"
                },
                "repo": {
                  "type": "string",
                  "description": "Repository name"
                },
                "page": {
                  "description": "Page number for pagination (min 1)",
                  "minimum": 1,
                  "type": "number"
                },
                "perPage": {
                  "type": "number",
                  "description": "Results per page for pagination (min 1, max 100)",
                  "maximum": 100,
                  "minimum": 1
                }
              },
              "type": "object",
              "required": [
                "owner",
                "repo"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___add_issue_comment",
          "description": "Add a comment to a specific issue in a GitHub repository.",
          "input_schema": {
            "json": {
              "properties": {
                "repo": {
                  "description": "Repository name",
                  "type": "string"
                },
                "owner": {
                  "type": "string",
                  "description": "Repository owner"
                },
                "issue_number": {
                  "type": "number",
                  "description": "Issue number to comment on"
                },
                "body": {
                  "description": "Comment content",
                  "type": "string"
                }
              },
              "type": "object",
              "required": [
                "owner",
                "repo",
                "issue_number",
                "body"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___get_tag",
          "description": "Get details about a specific git tag in a GitHub repository",
          "input_schema": {
            "json": {
              "required": [
                "owner",
                "repo",
                "tag"
              ],
              "properties": {
                "tag": {
                  "description": "Tag name",
                  "type": "string"
                },
                "owner": {
                  "description": "Repository owner",
                  "type": "string"
                },
                "repo": {
                  "description": "Repository name",
                  "type": "string"
                }
              },
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___get_commit",
          "description": "Get details for a commit from a GitHub repository",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "page": {
                  "description": "Page number for pagination (min 1)",
                  "minimum": 1,
                  "type": "number"
                },
                "perPage": {
                  "minimum": 1,
                  "type": "number",
                  "description": "Results per page for pagination (min 1, max 100)",
                  "maximum": 100
                },
                "sha": {
                  "description": "Commit SHA, branch name, or tag name",
                  "type": "string"
                },
                "owner": {
                  "description": "Repository owner",
                  "type": "string"
                },
                "repo": {
                  "type": "string",
                  "description": "Repository name"
                }
              },
              "required": [
                "owner",
                "repo",
                "sha"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___delete_file",
          "description": "Delete a file from a GitHub repository",
          "input_schema": {
            "json": {
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "Repository name"
                },
                "branch": {
                  "type": "string",
                  "description": "Branch to delete the file from"
                },
                "path": {
                  "description": "Path to the file to delete",
                  "type": "string"
                },
                "message": {
                  "type": "string",
                  "description": "Commit message"
                },
                "owner": {
                  "description": "Repository owner (username or organization)",
                  "type": "string"
                }
              },
              "type": "object",
              "required": [
                "owner",
                "repo",
                "path",
                "message",
                "branch"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___create_issue",
          "description": "Create a new issue in a GitHub repository.",
          "input_schema": {
            "json": {
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "Repository name"
                },
                "title": {
                  "type": "string",
                  "description": "Issue title"
                },
                "milestone": {
                  "description": "Milestone number",
                  "type": "number"
                },
                "labels": {
                  "items": {
                    "type": "string"
                  },
                  "description": "Labels to apply to this issue",
                  "type": "array"
                },
                "owner": {
                  "description": "Repository owner",
                  "type": "string"
                },
                "assignees": {
                  "description": "Usernames to assign to this issue",
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                "body": {
                  "description": "Issue body content",
                  "type": "string"
                }
              },
              "type": "object",
              "required": [
                "owner",
                "repo",
                "title"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___get_issue_comments",
          "description": "Get comments for a specific issue in a GitHub repository.",
          "input_schema": {
            "json": {
              "properties": {
                "owner": {
                  "description": "Repository owner",
                  "type": "string"
                },
                "per_page": {
                  "type": "number",
                  "description": "Number of records per page"
                },
                "repo": {
                  "description": "Repository name",
                  "type": "string"
                },
                "issue_number": {
                  "description": "Issue number",
                  "type": "number"
                },
                "page": {
                  "type": "number",
                  "description": "Page number"
                }
              },
              "required": [
                "owner",
                "repo",
                "issue_number"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___list_notifications",
          "description": "Lists all GitHub notifications for the authenticated user, including unread notifications, mentions, review requests, assignments, and updates on issues or pull requests. Use this tool whenever the user asks what to work on next, requests a summary of their GitHub activity, wants to see pending reviews, or needs to check for new updates or tasks. This tool is the primary way to discover actionable items, reminders, and outstanding work on GitHub. Always call this tool when asked what to work on next, what is pending, or what needs attention in GitHub.",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "page": {
                  "minimum": 1,
                  "type": "number",
                  "description": "Page number for pagination (min 1)"
                },
                "filter": {
                  "enum": [
                    "default",
                    "include_read_notifications",
                    "only_participating"
                  ],
                  "type": "string",
                  "description": "Filter notifications to, use default unless specified. Read notifications are ones that have already been acknowledged by the user. Participating notifications are those that the user is directly involved in, such as issues or pull requests they have commented on or created."
                },
                "owner": {
                  "type": "string",
                  "description": "Optional repository owner. If provided with repo, only notifications for this repository are listed."
                },
                "perPage": {
                  "type": "number",
                  "description": "Results per page for pagination (min 1, max 100)",
                  "minimum": 1,
                  "maximum": 100
                },
                "repo": {
                  "description": "Optional repository name. If provided with owner, only notifications for this repository are listed.",
                  "type": "string"
                },
                "since": {
                  "type": "string",
                  "description": "Only show notifications updated after the given time (ISO 8601 format)"
                },
                "before": {
                  "type": "string",
                  "description": "Only show notifications updated before the given time (ISO 8601 format)"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___list_code_scanning_alerts",
          "description": "List code scanning alerts in a GitHub repository.",
          "input_schema": {
            "json": {
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "The name of the repository."
                },
                "severity": {
                  "type": "string",
                  "description": "Filter code scanning alerts by severity",
                  "enum": [
                    "critical",
                    "high",
                    "medium",
                    "low",
                    "warning",
                    "note",
                    "error"
                  ]
                },
                "state": {
                  "description": "Filter code scanning alerts by state. Defaults to open",
                  "default": "open",
                  "enum": [
                    "open",
                    "closed",
                    "dismissed",
                    "fixed"
                  ],
                  "type": "string"
                },
                "tool_name": {
                  "type": "string",
                  "description": "The name of the tool used for code scanning."
                },
                "owner": {
                  "type": "string",
                  "description": "The owner of the repository."
                },
                "ref": {
                  "description": "The Git reference for the results you want to list.",
                  "type": "string"
                }
              },
              "type": "object",
              "required": [
                "owner",
                "repo"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___push_files",
          "description": "Push multiple files to a GitHub repository in a single commit",
          "input_schema": {
            "json": {
              "required": [
                "owner",
                "repo",
                "branch",
                "files",
                "message"
              ],
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "Repository name"
                },
                "branch": {
                  "type": "string",
                  "description": "Branch to push to"
                },
                "files": {
                  "items": {
                    "additionalProperties": false,
                    "properties": {
                      "content": {
                        "type": "string",
                        "description": "file content"
                      },
                      "path": {
                        "description": "path to the file",
                        "type": "string"
                      }
                    },
                    "required": [
                      "path",
                      "content"
                    ],
                    "type": "object"
                  },
                  "description": "Array of file objects to push, each object with path (string) and content (string)",
                  "type": "array"
                },
                "owner": {
                  "type": "string",
                  "description": "Repository owner"
                },
                "message": {
                  "type": "string",
                  "description": "Commit message"
                }
              },
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___get_secret_scanning_alert",
          "description": "Get details of a specific secret scanning alert in a GitHub repository.",
          "input_schema": {
            "json": {
              "properties": {
                "repo": {
                  "description": "The name of the repository.",
                  "type": "string"
                },
                "owner": {
                  "type": "string",
                  "description": "The owner of the repository."
                },
                "alertNumber": {
                  "description": "The number of the alert.",
                  "type": "number"
                }
              },
              "required": [
                "owner",
                "repo",
                "alertNumber"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___create_and_submit_pull_request_review",
          "description": "Create and submit a review for a pull request without review comments.",
          "input_schema": {
            "json": {
              "properties": {
                "commitID": {
                  "description": "SHA of commit to review",
                  "type": "string"
                },
                "owner": {
                  "description": "Repository owner",
                  "type": "string"
                },
                "body": {
                  "type": "string",
                  "description": "Review comment text"
                },
                "pullNumber": {
                  "description": "Pull request number",
                  "type": "number"
                },
                "repo": {
                  "type": "string",
                  "description": "Repository name"
                },
                "event": {
                  "type": "string",
                  "description": "Review action to perform",
                  "enum": [
                    "APPROVE",
                    "REQUEST_CHANGES",
                    "COMMENT"
                  ]
                }
              },
              "required": [
                "owner",
                "repo",
                "pullNumber",
                "body",
                "event"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___delete_pending_pull_request_review",
          "description": "Delete the requester's latest pending pull request review. Use this after the user decides not to submit a pending review, if you don't know if they already created one then check first.",
          "input_schema": {
            "json": {
              "required": [
                "owner",
                "repo",
                "pullNumber"
              ],
              "type": "object",
              "properties": {
                "pullNumber": {
                  "description": "Pull request number",
                  "type": "number"
                },
                "repo": {
                  "type": "string",
                  "description": "Repository name"
                },
                "owner": {
                  "type": "string",
                  "description": "Repository owner"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___search_users",
          "description": "Search for GitHub users",
          "input_schema": {
            "json": {
              "properties": {
                "perPage": {
                  "type": "number",
                  "maximum": 100,
                  "description": "Results per page for pagination (min 1, max 100)",
                  "minimum": 1
                },
                "sort": {
                  "type": "string",
                  "enum": [
                    "followers",
                    "repositories",
                    "joined"
                  ],
                  "description": "Sort field by category"
                },
                "order": {
                  "enum": [
                    "asc",
                    "desc"
                  ],
                  "type": "string",
                  "description": "Sort order"
                },
                "q": {
                  "type": "string",
                  "description": "Search query using GitHub users search syntax"
                },
                "page": {
                  "type": "number",
                  "description": "Page number for pagination (min 1)",
                  "minimum": 1
                }
              },
              "required": [
                "q"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___update_issue",
          "description": "Update an existing issue in a GitHub repository.",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "body": {
                  "type": "string",
                  "description": "New description"
                },
                "issue_number": {
                  "description": "Issue number to update",
                  "type": "number"
                },
                "state": {
                  "enum": [
                    "open",
                    "closed"
                  ],
                  "type": "string",
                  "description": "New state"
                },
                "milestone": {
                  "description": "New milestone number",
                  "type": "number"
                },
                "repo": {
                  "description": "Repository name",
                  "type": "string"
                },
                "owner": {
                  "description": "Repository owner",
                  "type": "string"
                },
                "title": {
                  "type": "string",
                  "description": "New title"
                },
                "labels": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "New labels"
                },
                "assignees": {
                  "description": "New assignees",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              },
              "required": [
                "owner",
                "repo",
                "issue_number"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___list_pull_requests",
          "description": "List pull requests in a GitHub repository.",
          "input_schema": {
            "json": {
              "required": [
                "owner",
                "repo"
              ],
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "Repository name"
                },
                "perPage": {
                  "type": "number",
                  "minimum": 1,
                  "description": "Results per page for pagination (min 1, max 100)",
                  "maximum": 100
                },
                "direction": {
                  "enum": [
                    "asc",
                    "desc"
                  ],
                  "description": "Sort direction",
                  "type": "string"
                },
                "base": {
                  "description": "Filter by base branch",
                  "type": "string"
                },
                "head": {
                  "description": "Filter by head user/org and branch",
                  "type": "string"
                },
                "sort": {
                  "description": "Sort by",
                  "enum": [
                    "created",
                    "updated",
                    "popularity",
                    "long-running"
                  ],
                  "type": "string"
                },
                "owner": {
                  "description": "Repository owner",
                  "type": "string"
                },
                "state": {
                  "type": "string",
                  "description": "Filter by state",
                  "enum": [
                    "open",
                    "closed",
                    "all"
                  ]
                },
                "page": {
                  "type": "number",
                  "description": "Page number for pagination (min 1)",
                  "minimum": 1
                }
              },
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___fork_repository",
          "description": "Fork a GitHub repository to your account or specified organization",
          "input_schema": {
            "json": {
              "properties": {
                "owner": {
                  "type": "string",
                  "description": "Repository owner"
                },
                "repo": {
                  "type": "string",
                  "description": "Repository name"
                },
                "organization": {
                  "description": "Organization to fork to",
                  "type": "string"
                }
              },
              "required": [
                "owner",
                "repo"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___create_repository",
          "description": "Create a new GitHub repository in your account",
          "input_schema": {
            "json": {
              "required": [
                "name"
              ],
              "type": "object",
              "properties": {
                "description": {
                  "type": "string",
                  "description": "Repository description"
                },
                "name": {
                  "type": "string",
                  "description": "Repository name"
                },
                "private": {
                  "description": "Whether repo should be private",
                  "type": "boolean"
                },
                "autoInit": {
                  "description": "Initialize with README",
                  "type": "boolean"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___request_copilot_review",
          "description": "Request a GitHub Copilot code review for a pull request. Use this for automated feedback on pull requests, usually before requesting a human reviewer.",
          "input_schema": {
            "json": {
              "properties": {
                "owner": {
                  "type": "string",
                  "description": "Repository owner"
                },
                "repo": {
                  "type": "string",
                  "description": "Repository name"
                },
                "pullNumber": {
                  "description": "Pull request number",
                  "type": "number"
                }
              },
              "required": [
                "owner",
                "repo",
                "pullNumber"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___create_pull_request",
          "description": "Create a new pull request in a GitHub repository.",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "repo": {
                  "description": "Repository name",
                  "type": "string"
                },
                "base": {
                  "type": "string",
                  "description": "Branch to merge into"
                },
                "draft": {
                  "type": "boolean",
                  "description": "Create as draft PR"
                },
                "maintainer_can_modify": {
                  "description": "Allow maintainer edits",
                  "type": "boolean"
                },
                "body": {
                  "type": "string",
                  "description": "PR description"
                },
                "title": {
                  "type": "string",
                  "description": "PR title"
                },
                "owner": {
                  "description": "Repository owner",
                  "type": "string"
                },
                "head": {
                  "type": "string",
                  "description": "Branch containing changes"
                }
              },
              "required": [
                "owner",
                "repo",
                "title",
                "head",
                "base"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___search_issues",
          "description": "Search for issues in GitHub repositories.",
          "input_schema": {
            "json": {
              "type": "object",
              "required": [
                "q"
              ],
              "properties": {
                "sort": {
                  "enum": [
                    "comments",
                    "reactions",
                    "reactions-+1",
                    "reactions--1",
                    "reactions-smile",
                    "reactions-thinking_face",
                    "reactions-heart",
                    "reactions-tada",
                    "interactions",
                    "created",
                    "updated"
                  ],
                  "type": "string",
                  "description": "Sort field by number of matches of categories, defaults to best match"
                },
                "page": {
                  "description": "Page number for pagination (min 1)",
                  "type": "number",
                  "minimum": 1
                },
                "order": {
                  "enum": [
                    "asc",
                    "desc"
                  ],
                  "type": "string",
                  "description": "Sort order"
                },
                "perPage": {
                  "type": "number",
                  "maximum": 100,
                  "description": "Results per page for pagination (min 1, max 100)",
                  "minimum": 1
                },
                "q": {
                  "type": "string",
                  "description": "Search query using GitHub issues search syntax"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___list_tags",
          "description": "List git tags in a GitHub repository",
          "input_schema": {
            "json": {
              "properties": {
                "owner": {
                  "description": "Repository owner",
                  "type": "string"
                },
                "repo": {
                  "description": "Repository name",
                  "type": "string"
                },
                "perPage": {
                  "maximum": 100,
                  "description": "Results per page for pagination (min 1, max 100)",
                  "type": "number",
                  "minimum": 1
                },
                "page": {
                  "minimum": 1,
                  "description": "Page number for pagination (min 1)",
                  "type": "number"
                }
              },
              "required": [
                "owner",
                "repo"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___get_pull_request",
          "description": "Get details of a specific pull request in a GitHub repository.",
          "input_schema": {
            "json": {
              "properties": {
                "owner": {
                  "description": "Repository owner",
                  "type": "string"
                },
                "pullNumber": {
                  "description": "Pull request number",
                  "type": "number"
                },
                "repo": {
                  "type": "string",
                  "description": "Repository name"
                }
              },
              "required": [
                "owner",
                "repo",
                "pullNumber"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___merge_pull_request",
          "description": "Merge a pull request in a GitHub repository.",
          "input_schema": {
            "json": {
              "type": "object",
              "required": [
                "owner",
                "repo",
                "pullNumber"
              ],
              "properties": {
                "commit_title": {
                  "type": "string",
                  "description": "Title for merge commit"
                },
                "commit_message": {
                  "description": "Extra detail for merge commit",
                  "type": "string"
                },
                "merge_method": {
                  "type": "string",
                  "enum": [
                    "merge",
                    "squash",
                    "rebase"
                  ],
                  "description": "Merge method"
                },
                "repo": {
                  "description": "Repository name",
                  "type": "string"
                },
                "owner": {
                  "type": "string",
                  "description": "Repository owner"
                },
                "pullNumber": {
                  "description": "Pull request number",
                  "type": "number"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___get_notification_details",
          "description": "Get detailed information for a specific GitHub notification, always call this tool when the user asks for details about a specific notification, if you don't know the ID list notifications first.",
          "input_schema": {
            "json": {
              "properties": {
                "notificationID": {
                  "description": "The ID of the notification",
                  "type": "string"
                }
              },
              "type": "object",
              "required": [
                "notificationID"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___get_pull_request_reviews",
          "description": "Get reviews for a specific pull request.",
          "input_schema": {
            "json": {
              "properties": {
                "repo": {
                  "description": "Repository name",
                  "type": "string"
                },
                "pullNumber": {
                  "type": "number",
                  "description": "Pull request number"
                },
                "owner": {
                  "description": "Repository owner",
                  "type": "string"
                }
              },
              "required": [
                "owner",
                "repo",
                "pullNumber"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___assign_copilot_to_issue",
          "description": "Assign Copilot to a specific issue in a GitHub repository.\n\nThis tool can help with the following outcomes:\n- a Pull Request created with source code changes to resolve the issue\n\n\nMore information can be found at:\n- https://docs.github.com/en/copilot/using-github-copilot/using-copilot-coding-agent-to-work-on-tasks/about-assigning-tasks-to-copilot\n",
          "input_schema": {
            "json": {
              "properties": {
                "issueNumber": {
                  "description": "Issue number",
                  "type": "number"
                },
                "repo": {
                  "description": "Repository name",
                  "type": "string"
                },
                "owner": {
                  "description": "Repository owner",
                  "type": "string"
                }
              },
              "required": [
                "owner",
                "repo",
                "issueNumber"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "github___mark_all_notifications_read",
          "description": "Mark all notifications as read",
          "input_schema": {
            "json": {
              "properties": {
                "owner": {
                  "description": "Optional repository owner. If provided with repo, only notifications for this repository are marked as read.",
                  "type": "string"
                },
                "lastReadAt": {
                  "description": "Describes the last point that notifications were checked (optional). Default: Now",
                  "type": "string"
                },
                "repo": {
                  "description": "Optional repository name. If provided with owner, only notifications for this repository are marked as read.",
                  "type": "string"
                }
              },
              "type": "object"
            }
          }
        }
      }
    ],
    "magic_ui": [
      {
        "ToolSpecification": {
          "name": "magic_ui___logo_search",
          "description": "\nSearch and return logos in specified format (JSX, TSX, SVG).\nSupports single and multiple logo searches with category filtering.\nCan return logos in different themes (light/dark) if available.\n\nWhen to use this tool:\n1. When user types \"/logo\" command (e.g., \"/logo GitHub\")\n2. When user asks to add a company logo that's not in the local project\n\nExample queries:\n- Single company: [\"discord\"]\n- Multiple companies: [\"discord\", \"github\", \"slack\"]\n- Specific brand: [\"microsoft office\"]\n- Command style: \"/logo GitHub\" -> [\"github\"]\n- Request style: \"Add Discord logo to the project\" -> [\"discord\"]\n\nFormat options:\n- TSX: Returns TypeScript React component\n- JSX: Returns JavaScript React component\n- SVG: Returns raw SVG markup\n\nEach result includes:\n- Component name (e.g., DiscordIcon)\n- Component code\n- Import instructions\n",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "required": [
                "queries",
                "format"
              ],
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "queries": {
                  "description": "List of company names to search for logos",
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                "format": {
                  "enum": [
                    "JSX",
                    "TSX",
                    "SVG"
                  ],
                  "description": "Output format",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "magic_ui___a21st_magic_component_inspiration",
          "description": "\n\"Use this tool when the user wants to see component, get inspiration, or /21st fetch data and previews from 21st.dev. This tool returns the JSON data of matching components without generating new code. This tool ONLY returns the text snippet for that UI component. \nAfter calling this tool, you must edit or add files to integrate the snippet into the codebase.\"\n",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "type": "object",
              "required": [
                "message",
                "searchQuery"
              ],
              "properties": {
                "message": {
                  "description": "Full users message",
                  "type": "string"
                },
                "searchQuery": {
                  "description": "Search query for 21st.dev (library for searching UI components) to find a UI component that matches the user's message. Must be a two-four words max or phrase",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "magic_ui___a21st_magic_component_builder",
          "description": "\n\"Use this tool when the user requests a new UI component—e.g., mentions /ui, /21 /21st, or asks for a button, input, dialog, table, form, banner, card, or other React component.\nThis tool ONLY returns the text snippet for that UI component. \nAfter calling this tool, you must edit or add files to integrate the snippet into the codebase.\"\n",
          "input_schema": {
            "json": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "absolutePathToCurrentFile": {
                  "description": "Absolute path to the current file to which we want to apply changes",
                  "type": "string"
                },
                "absolutePathToProjectDirectory": {
                  "type": "string",
                  "description": "Absolute path to the project root directory"
                },
                "context": {
                  "type": "string",
                  "description": "Extract additional context about what should be done to create a ui component/page based on the user's message, search query, and conversation history, files. Don't halucinate and be on point."
                },
                "message": {
                  "type": "string",
                  "description": "Full users message"
                },
                "searchQuery": {
                  "type": "string",
                  "description": "Generate a search query for 21st.dev (library for searching UI components) to find a UI component that matches the user's message. Must be a two-four words max or phrase"
                }
              },
              "required": [
                "message",
                "searchQuery",
                "absolutePathToCurrentFile",
                "absolutePathToProjectDirectory",
                "context"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "magic_ui___a21st_magic_component_refiner",
          "description": "\n\"Use this tool when the user requests to re-design/refine/improve current UI component with /ui or /21 commands, \nor when context is about improving, or refining UI for a React component or molecule (NOT for big pages).\nThis tool improves UI of components and returns redesigned version of the component and instructions on how to implement it.\"\n",
          "input_schema": {
            "json": {
              "required": [
                "userMessage",
                "absolutePathToRefiningFile",
                "context"
              ],
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "properties": {
                "userMessage": {
                  "type": "string",
                  "description": "Full user's message about UI refinement"
                },
                "context": {
                  "description": "Extract the specific UI elements and aspects that need improvement based on user messages, code, and conversation history. Identify exactly which components (buttons, forms, modals, etc.) the user is referring to and what aspects (styling, layout, responsiveness, etc.) they want to enhance. Do not include generic improvements - focus only on what the user explicitly mentions or what can be reasonably inferred from the available context. If nothing specific is mentioned or you cannot determine what needs improvement, return an empty string.",
                  "type": "string"
                },
                "absolutePathToRefiningFile": {
                  "description": "Absolute path to the file that needs to be refined",
                  "type": "string"
                }
              }
            }
          }
        }
      }
    ]
  },
  "context_manager": {
    "max_context_files_size": 150000,
    "global_config": {
      "paths": [
        ".amazonq/rules/**/*.md",
        "README.md",
        "AmazonQ.md"
      ],
      "hooks": {}
    },
    "current_profile": "docker",
    "profile_config": {
      "paths": [
        "~/docker/docs/README.md",
        "~/docker/core/traefik/compose.yml",
        "~/docker/core/traefik/traefik-data/dynamic/"
      ],
      "hooks": {
        "project-structure": {
          "trigger": "conversation_start",
          "type": "inline",
          "disabled": false,
          "timeout_ms": 30000,
          "max_output_size": 10240,
          "cache_ttl_seconds": 0,
          "command": "tree ~/docker"
        }
      }
    }
  },
  "context_message_length": 8124,
  "latest_summary": null,
  "model": "CLAUDE_3_7_SONNET_20250219_V1_0"
}